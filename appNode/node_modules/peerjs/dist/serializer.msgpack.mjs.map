{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,EgCSY,EGTA,EAKA,EAyDA,EAKA,EAKA,EAOA,EAOA,E,E,E,EH7EL,EGTA,EAKA,EAyDA,EAKA,EAKA,EAOA,EAOA,E,E,C,E,E,E,oB,I,I,I,E,C,E5BtFD,SAAU,EAAW,CAAY,EACrC,MAAO,GAAA,MAAA,CAAG,EAAO,EAAI,IAAM,GAAE,MAAA,MAAA,CAAK,KAAK,GAAA,CAAI,GAAM,QAAA,CAAS,IAAI,QAAA,CAAS,EAAG,KAC5E,C,E,E,U,I,EEFA,mDAAkD;AEAlD;;CAEG,EACH,IAAA,EACE,SAAqB,CAAY,CAAW,CAAgB,EAAvC,IAAA,CAAA,IAAA,CAAA,EAAuB,IAAA,CAAA,IAAA,CAAA,CAAmB,E,E,C,E,E,E,c,I,G,I,G,E,S,C,C,C,E,M,A,C,E,O,c,E,A,C,C,U,E,A,C,Y,O,S,C,C,C,E,E,S,C,C,G,S,C,C,C,E,I,I,K,E,O,S,C,c,C,I,C,E,I,C,C,C,E,C,C,C,E,A,C,C,E,E,E,E,S,C,C,C,E,G,A,Y,O,G,A,O,E,M,A,U,uB,O,G,iC,S,I,I,C,W,C,C,C,E,E,G,E,S,C,A,O,E,O,M,C,G,C,E,S,C,E,S,C,I,C,C,GIJjE,EAAA,WAAA,EAAA,SAAA,CAAA,EACE,SAAA,EAAY,CAAe,EAA3B,IAAA,EACE,EAAA,IAAA,CAAA,IAAA,CAAM,IAAQ,IAAA,C,OAId,OAAO,cAAA,CAAe,EADsB,OAAO,MAAA,CAAO,EAAY,SAAtE,GAGA,OAAO,cAAA,CAAe,EAAM,OAAQ,CAClC,aAAc,CAAA,EACd,WAAY,CAAA,EACZ,MAAO,EAAY,IAAnB,AACD,G,CACH,CACF,OAdiC,EAAA,EAAA,GAcjC,CAAA,EAdiC,OEc3B,SAAU,EAAS,CAAc,CAAE,CAAc,CAAE,CAAa,EACpE,IAAM,EAAO,KAAK,KAAA,CAAM,EAAQ,YAEhC,EAAK,SAAA,CAAU,EAAQ,GACvB,EAAK,SAAA,CAAU,EAAS,EAFZ,EAGd,CAEM,SAAU,EAAS,CAAc,CAAE,CAAc,EAGrD,OAAO,AAAO,WAFD,EAAK,QAAA,CAAS,GACf,EAA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,E,E,E,C,M,E,K,W,G,A,E,C,C,E,C,M,C,C,E,C,O,C,C,E,A,E,K,E,C,I,E,A,E,O,E,C,K,E,G,M,E,G,O,E,E,E,A,Y,O,Q,C,C,C,O,Q,C,C,W,O,I,A,C,E,E,S,E,C,E,O,S,C,E,O,A,S,C,E,G,E,M,A,U,mC,K,G,G,C,G,E,E,G,C,E,A,E,C,C,E,C,E,M,C,C,C,E,C,E,K,E,C,A,C,E,E,M,A,G,E,I,C,G,C,E,E,I,A,G,C,A,C,E,E,I,C,E,C,C,E,C,E,I,C,O,E,O,E,E,A,G,C,E,C,A,E,C,C,E,C,E,K,C,A,E,C,C,E,E,K,E,K,E,E,E,K,M,E,O,E,K,G,C,M,C,C,E,C,K,C,C,C,M,E,E,K,G,E,C,C,E,C,E,C,E,C,Q,M,E,E,E,G,C,G,G,E,I,C,G,G,Q,S,G,C,C,E,A,C,E,E,I,A,E,M,C,G,C,C,E,M,C,E,A,G,C,A,I,C,C,E,E,A,I,C,C,E,A,E,C,E,E,Q,C,G,A,I,C,C,E,E,C,C,G,C,C,E,C,C,C,E,E,C,C,E,C,C,C,E,A,E,C,E,K,C,C,C,E,C,K,C,G,A,I,C,C,E,E,E,K,C,C,C,E,C,C,E,K,C,C,C,E,C,E,E,K,C,G,G,E,K,C,C,C,E,C,C,E,K,C,C,C,E,C,E,G,C,I,C,G,K,C,C,C,E,E,E,G,C,G,G,E,I,C,G,G,Q,C,E,E,I,C,E,E,C,M,E,C,E,C,E,E,C,E,C,Q,C,E,E,C,C,G,A,E,C,C,E,C,M,C,C,E,C,M,C,M,C,C,E,C,C,C,E,C,K,E,K,C,C,C,E,C,E,E,C,C,C,E,E,S,C,E,G,C,O,a,C,M,A,U,wC,I,E,E,C,C,O,a,C,C,O,E,E,I,C,G,C,E,A,Y,O,S,S,G,C,C,O,Q,C,G,E,C,E,E,Q,E,S,E,U,C,C,O,a,C,C,W,O,I,A,E,C,E,S,E,C,E,C,C,E,C,C,C,E,E,S,C,E,O,I,Q,S,C,C,C,G,A,S,C,C,C,C,C,C,C,E,Q,O,C,G,I,C,S,C,E,E,C,M,E,K,C,E,E,E,E,E,E,A,C,E,C,C,E,C,E,E,I,C,E,K,C,E,C,C,E,E,S,C,E,O,I,Y,E,C,I,C,C,C,E,I,A,E,I,E,E,E,E,S,C,C,C,C,C,E,G,C,O,a,C,M,A,U,wC,I,E,E,E,K,C,E,G,E,E,E,E,C,O,E,C,E,E,Q,E,S,E,U,C,C,O,a,C,C,W,O,I,A,E,E,S,E,C,E,C,C,E,E,C,C,C,E,C,S,C,E,O,I,Q,S,C,C,C,E,E,I,C,C,E,E,E,E,E,G,E,E,E,E,C,C,C,S,E,C,C,C,E,G,K,C,E,E,C,C,E,C,I,K,Y,E,Q,O,C,E,K,C,C,E,I,C,E,G,E,C,C,E,C,E,C,E,C,M,E,C,E,C,C,E,C,E,C,E,C,C,S,E,C,E,E,O,E,C,S,E,C,E,E,Q,E,C,S,E,C,C,C,E,E,G,E,K,G,A,E,M,E,E,C,C,E,C,E,C,C,C,E,C,E,C,C,EnB3DM,EAAoB,SAAC,CAAY,EACrC,IAAM,EAAU,OAAO,EAEvB,MAAO,AAAY,WAAZ,GAAwB,AAAY,WAAZ,CACjC,EAqBM,EAAa,IAAI,SAAS,IAAI,YAAY,IAC1C,EAAc,IAAI,WAAW,EAAW,MAA9C,EAIa,EAA8C,WACzD,GAAI,CACF,kDAAkD;AAClD,yCAAyC;AACzC,EAAW,OAAA,CAAQ,EACpB,CAAC,MAAO,EAAQ,CACf,OAAO,EAAE,WAAT,AACD,CACD,MAAM,AAAI,MAAM,gBAClB,IAEM,EAAY,IAAI,EAA8B,qBAE9C,EAAyB,IAAI,EAEnC,EAAA,WAAA,EAAA,WASE,SAAA,EACmB,CAAoF,CACpF,CAAuC,CACvC,CAAyB,CACzB,CAAyB,CACzB,CAA2B,CAC3B,CAAyB,CACzB,CAAyB,CACzB,CAAsD,EAPtD,KAAA,IAAA,GAAA,CAAA,EAAkD,AAAA,EAAe,YAAjE,AAAA,EACA,KAAA,IAAA,GAAA,CAAA,EAAuB,KAAA,CAAvB,EACA,KAAA,IAAA,GAAA,CAAA,EYvEK,UZuEL,EACA,KAAA,IAAA,GAAA,CAAA,EYxEK,UZwEL,EACA,KAAA,IAAA,GAAA,CAAA,EYzEK,UZyEL,EACA,KAAA,IAAA,GAAA,CAAA,EY1EK,UZ0EL,EACA,KAAA,IAAA,GAAA,CAAA,EY3EK,UZ2EL,EACA,KAAA,IAAA,GAAA,CAAA,EAAA,CAAA,EAPA,IAAA,CAAA,cAAA,CAAA,EACA,IAAA,CAAA,OAAA,CAAA,EACA,IAAA,CAAA,YAAA,CAAA,EACA,IAAA,CAAA,YAAA,CAAA,EACA,IAAA,CAAA,cAAA,CAAA,EACA,IAAA,CAAA,YAAA,CAAA,EACA,IAAA,CAAA,YAAA,CAAA,EACA,IAAA,CAAA,UAAA,CAAA,EAhBX,IAAA,CAAA,QAAA,CAAW,EACX,IAAA,CAAA,GAAA,CAAM,EAEN,IAAA,CAAA,IAAA,CAAO,EACP,IAAA,CAAA,KAAA,CAAQ,EACR,IAAA,CAAA,QAAA,CA5BiB,GA6BR,IAAA,CAAA,KAAA,CAA2B,EAAE,AAW3C,CAmiBL,OAjiBU,EAAA,SAAA,CAAA,iBAAA,CAAR,WACE,IAAI,CAAC,QAAA,CAAW,EAChB,IAAI,CAAC,QAAA,CA5CkB,GA6CvB,IAAI,CAAC,KAAA,CAAM,MAAA,CAAS,CAEpB,8DAA6D;AAC/D,EAEQ,EAAA,SAAA,CAAA,SAAA,CAAR,SAAkB,CAAwC,EACxD,IAAI,CAAC,KAAA,CAAQ,AAAA,EAAiB,GAC9B,IAAI,CAAC,IAAA,CAAO,AiB9EV,SAAyB,CAAyD,EACtF,GAAI,aAAkB,YACpB,OAAO,IAAI,SAAS,GAGtB,IAAM,EAAa,EAAiB,GACpC,OAAO,IAAI,SAAS,EAAW,MAAA,CAAQ,EAAW,UAAA,CAAY,EAAW,UAAzE,CACF,EjBuE+B,IAAI,CAAC,KAAhC,EACA,IAAI,CAAC,GAAA,CAAM,CACb,EAEQ,EAAA,SAAA,CAAA,YAAA,CAAR,SAAqB,CAAwC,EAC3D,GAAI,AAzDmB,KAyDnB,IAAI,CAAC,QAAA,EAAoC,IAAI,CAAC,YAAA,CAAa,GAExD,CACL,IAAM,EAAgB,IAAI,CAAC,KAAA,CAAM,QAAA,CAAS,IAAI,CAAC,GAA/C,EACM,EAAU,AAAA,EAAiB,GAG3B,EAAY,IAAI,WAAW,EAAc,MAAA,CAAS,EAAQ,MAAhE,EACA,EAAU,GAAA,CAAI,GACd,EAAU,GAAA,CAAI,EAAS,EAAc,MAArC,EACA,IAAI,CAAC,SAAA,CAAU,EAChB,MAVC,IAAI,CAAC,SAAA,CAAU,EAWnB,EAEQ,EAAA,SAAA,CAAA,YAAA,CAAR,SAAqB,CAAY,EAC/B,OAAO,IAAI,CAAC,IAAA,CAAK,UAAA,CAAa,IAAI,CAAC,GAAA,EAAO,CAC5C,EAEQ,EAAA,SAAA,CAAA,oBAAA,CAAR,SAA6B,CAAiB,EACtC,IAAE,EAAI,AAAU,IAAI,CAAd,IAAA,CAAE,EAAG,AAAK,IAAI,CAAT,GAAX,CACN,OAAO,AAAI,WAAW,SAAA,MAAA,CAAS,EAAK,UAAA,CAAa,EAAG,QAAA,MAAA,CAAO,EAAK,UAAA,CAAU,6BAAA,MAAA,CAA4B,EAAS,KACjH,EAEA;;;KAGG,EACI,EAAA,SAAA,CAAA,MAAA,CAAP,SAAc,CAAwC,EACpD,IAAI,CAAC,iBAAL,GACA,IAAI,CAAC,SAAA,CAAU,GAEf,IAAM,EAAS,IAAI,CAAC,YAApB,GACA,GAAI,IAAI,CAAC,YAAA,CAAa,GACpB,MAAM,IAAI,CAAC,oBAAA,CAAqB,IAAI,CAAC,GADvC,EAGA,OAAO,CACT,EAEQ,EAAA,SAAA,CAAA,WAAA,CAAR,SAAoB,CAAwC,E,O,E,I,C,S,C,E,O,E,K,E,K,EAC1D,IAAI,CAAC,iBAAL,GACA,IAAI,CAAC,SAAA,CAAU,G,E,K,C,C,M,EAER,GAAA,CAAA,IAAI,CAAC,YAAA,CAAa,GAAlB,MAAA,CAAA,CAAA,OAAA,GAAA,EAAA,CACL,MAAA,CAAA,CAAA,OAAA,GAAM,IAAI,CAAC,YAAL,GAAmB,A,M,E,OAAzB,EAAA,IAAA,G,C,C,O,G,E,A,M,E,M,C,C,Q,G,A,C,EAEH,EAEY,EAAA,SAAA,CAAA,WAAA,CAAb,SAAyB,CAAuD,M,E,E,E,E,E,E,E,E,O,E,I,C,E,K,E,E,K,E,E,W,I,E,E,E,E,E,E,E,O,E,I,C,S,C,E,O,E,K,E,K,EAC1E,EAAU,CAAA,E,E,K,C,C,M,E,E,I,C,I,C,C,E,E,E,G,EAEa,EAAA,EAAA,G,E,K,C,C,M,E,M,C,C,O,G,E,I,G,A,M,E,G,A,C,E,E,I,E,E,I,C,M,C,C,O,G,E,CACzB,GADe,EAAM,EAAA,KAAN,CACX,EACF,MAAM,IAAI,CAAC,oBAAA,CAAqB,IAAI,CAAC,QADvC,EAIA,IAAI,CAAC,YAAA,CAAa,GAElB,GAAI,CACF,EAAS,IAAI,CAAC,YAAd,GACA,EAAU,CAAA,CACX,CAAC,MAAO,EAAG,CACV,GAAI,CAAE,CAAA,aAAa,CAAA,EACjB,MAAM,CAAG,WAAU;AAErB,cAAc;AACf,CACD,IAAI,CAAC,QAAA,EAAY,IAAI,CAAC,GAAtB,C,E,K,C,C,M,E,M,C,C,O,G,E,A,M,E,M,C,C,O,G,G,A,M,E,O,E,C,M,E,I,E,E,C,C,O,G,G,A,M,E,G,E,I,C,I,C,C,G,G,G,E,C,C,G,C,E,I,E,C,E,E,M,A,C,E,M,C,C,O,G,E,C,M,C,C,O,G,E,I,C,G,A,M,E,E,I,G,E,K,C,C,M,E,M,C,C,O,G,G,A,M,G,G,E,M,E,K,C,M,C,C,Y,G,A,M,G,M,C,C,Y,G,A,M,GAGF,GAAI,EAAS,CACX,GAAI,IAAI,CAAC,YAAA,CAAa,GACpB,MAAM,IAAI,CAAC,oBAAA,CAAqB,IAAI,CAAC,QADvC,EAGA,MAAA,CAAA,CAAA,QAAA,GAAO,EAAM,AACd,CAGD,MADM,EAA8B,IAAI,CAAhC,EAAQ,EAAA,QAAA,CAAE,EAAG,EAAA,GAAA,CAAE,EAAQ,EAAA,QAAzB,CACA,AAAI,WACR,gCAAA,MAAA,CAAgC,AAAA,EAAW,GAAS,QAAA,MAAA,CAAO,EAAQ,MAAA,MAAA,CAAK,EAAG,2B,C,E,E,G,C,G,C,E,O,C,E,S,C,C,C,E,S,E,C,E,G,C,E,E,I,C,G,C,M,E,C,E,E,C,C,S,E,C,E,G,C,E,E,K,C,G,C,M,E,C,E,E,C,C,S,E,C,M,C,C,E,I,C,E,E,K,E,A,C,C,E,E,K,Y,E,E,I,E,S,C,E,E,E,E,E,I,C,E,E,C,E,A,C,E,E,K,C,E,G,E,C,E,I,G,EAE9E,EAEM,EAAA,SAAA,CAAA,iBAAA,CAAP,SACE,CAAuD,EAEvD,OAAO,IAAI,CAAC,gBAAA,CAAiB,EAAQ,CAAA,EACvC,EAEO,EAAA,SAAA,CAAA,YAAA,CAAP,SAAoB,CAAuD,EACzE,OAAO,IAAI,CAAC,gBAAA,CAAiB,EAAQ,CAAA,EACvC,EAEe,EAAA,SAAA,CAAA,gBAAA,CAAf,SAAgC,CAAuD,CAAE,CAAgB,E,O,E,I,C,U,e,E,E,E,E,E,E,E,E,O,E,I,C,S,C,E,O,E,K,E,K,EACnG,EAAwB,EACxB,EAAiB,G,E,K,C,C,M,E,E,I,C,I,C,C,E,G,G,G,EAEM,EAAA,EAAA,G,E,K,C,C,M,E,M,C,C,O,G,E,E,I,I,A,M,E,G,A,C,E,E,I,E,E,I,C,M,C,C,O,G,G,CACzB,GADe,EAAM,EAAA,KAAN,CACX,GAAW,AAAmB,IAAnB,EACb,MAAM,IAAI,CAAC,oBAAA,CAAqB,IAAI,CAAC,QADvC,EAIA,IAAI,CAAC,YAAA,CAAa,GAEd,IACF,EAAiB,IAAI,CAAC,aAAtB,GACA,EAAwB,CAAA,EACxB,IAAI,CAAC,QAAL,I,E,K,C,C,M,E,E,I,C,I,C,C,E,G,G,E,E,K,C,C,M,EAKQ,MAAA,CAAA,CAAA,OAAA,GAAA,EAAA,IAAI,CAAC,YAAL,IAAA,AAAN,MAAA,EAAA,MAAA,CAAA,CAAA,OAAA,GAAA,EAAA,IAAA,GAAA,A,M,EACA,GADA,EAAA,IAAA,GACI,AAAqB,GAArB,EAAE,EACJ,MAAA,CAAA,CAAA,OAAA,GAAA,EAAA,C,M,C,C,O,G,E,A,M,E,M,C,C,O,G,G,A,M,EAIJ,GAAI,CAAE,CAAA,A,C,E,E,I,E,YAAa,CAAA,EACjB,MAAM,CAAG,WAAU;A,M,C,C,O,G,G,A,M,GAIvB,IAAI,CAAC,QAAA,EAAY,IAAI,CAAC,GAAtB,C,E,K,C,E,M,G,M,C,C,O,G,E,A,M,G,M,C,C,O,G,G,A,M,G,O,E,C,M,E,I,E,E,C,C,O,G,G,A,M,G,G,E,I,C,I,C,C,I,G,G,E,C,C,G,C,E,I,E,C,E,E,M,A,C,E,M,C,C,O,G,G,C,M,C,C,O,G,E,E,I,C,I,A,M,G,E,I,G,E,K,C,E,M,G,M,C,C,O,G,G,A,M,G,G,E,M,E,K,C,M,C,C,Y,G,A,M,G,M,C,C,Y,G,A,M,G,M,C,C,Q,G,A,C,E,EAEH,EAEO,EAAA,SAAA,CAAA,YAAA,CAAR,WACE,EAAQ,OAAa,CACnB,IAAM,EAAW,IAAI,CAAC,YAAtB,GACI,EAAM,KAAA,EAEV,GAAI,GAAY,IAEd,EAAS,EAAW,SACf,GAAI,EAAW,KACpB,GAAI,EAAW,IAEb,EAAS,OACJ,GAAI,EAAW,IAAM,CAC1B,iCAAiC;AACjC,IAAM,EAAO,EAAW,IACxB,GAAI,AAAS,I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CE,IAAM,EAAQ,IAAI,CAAC,IAAA,CAAK,QAAA,CAAS,IAAI,CAAC,GAAtC,EAEA,OADA,IAAI,CAAC,GAAA,EAAO,EACL,CACT,EAEQ,EAAA,SAAA,CAAA,OAAA,CAAR,WACE,IYjkBsB,EAAgB,EZikBhC,GYjkBgB,EZikBE,IAAI,CAAC,IAAA,CYjkBS,EZikBH,IAAI,CAAC,GAAxC,CY9jBK,AAAO,WAFD,EAAK,SAAA,CAAU,GAChB,EAAK,SAAA,CAAU,EAAS,IZikBlC,OADA,IAAI,CAAC,GAAA,EAAO,EACL,CACT,EAEQ,EAAA,SAAA,CAAA,OAAA,CAAR,WACE,IAAM,EAAQ,AAAA,EAAS,IAAI,CAAC,IAAA,CAAM,IAAI,CAAC,GAAvC,EAEA,OADA,IAAI,CAAC,GAAA,EAAO,EACL,CACT,EAEQ,EAAA,SAAA,CAAA,OAAA,CAAR,WACE,IAAM,EAAQ,IAAI,CAAC,IAAA,CAAK,UAAA,CAAW,IAAI,CAAC,GAAxC,EAEA,OADA,IAAI,CAAC,GAAA,EAAO,EACL,CACT,EAEQ,EAAA,SAAA,CAAA,OAAA,CAAR,WACE,IAAM,EAAQ,IAAI,CAAC,IAAA,CAAK,UAAA,CAAW,IAAI,CAAC,GAAxC,EAEA,OADA,IAAI,CAAC,GAAA,EAAO,EACL,CACT,EACF,CAAA,I,G,C,E,E,G,sB,I,GqBlnBA,8BAA6B;A,I,G,S,C,C,C,E,I,E,E,E,E,E,C,M,E,K,W,G,A,E,C,C,E,C,M,C,C,E,C,O,C,C,E,A,E,K,E,C,I,E,A,E,O,E,C,K,E,G,M,E,G,O,E,E,E,A,Y,O,Q,C,C,C,O,Q,C,C,W,O,I,A,C,E,E,S,E,C,E,O,S,C,E,O,A,S,C,E,G,E,M,A,U,mC,K,G,G,C,G,E,E,G,C,E,A,E,C,C,E,C,E,M,C,C,C,E,C,E,K,E,C,A,C,E,E,M,A,G,E,I,C,G,C,E,E,I,A,G,C,A,C,E,E,I,C,E,C,C,E,C,E,I,C,O,E,O,E,E,A,G,C,E,C,A,E,C,C,E,C,E,K,C,A,E,C,C,E,E,K,E,K,E,E,E,K,M,E,O,E,K,G,C,M,C,C,E,C,K,C,C,C,M,E,E,K,G,E,C,C,E,C,E,C,E,C,Q,M,E,E,E,G,C,G,G,E,I,C,G,G,Q,S,G,C,C,E,A,C,E,E,I,A,E,M,C,G,C,C,E,M,C,E,A,G,C,A,I,C,C,E,E,A,I,C,C,E,A,E,C,E,E,Q,C,G,A,I,C,C,E,E,C,C,G,C,C,E,C,C,C,E,E,C,C,E,C,C,C,E,A,E,C,E,K,C,C,C,E,C,K,C,G,A,I,C,C,E,E,E,K,C,C,C,E,C,C,E,K,C,C,C,E,C,E,E,K,C,G,G,E,K,C,C,C,E,C,C,E,K,C,C,C,E,C,E,G,C,I,C,G,K,C,C,C,E,E,E,G,C,G,G,E,I,C,G,G,Q,C,E,E,I,C,E,E,C,M,E,C,E,C,E,E,C,E,C,Q,C,E,E,C,C,G,A,E,C,C,E,C,M,C,C,E,C,M,C,M,C,C,E,C,C,C,E,C,K,E,K,C,C,C,E,C,E,E,C,C,C,E,G,S,C,E,O,I,Y,G,C,I,C,C,C,E,I,A,E,I,G,E,E,G,S,C,C,C,C,C,E,G,C,O,a,C,M,A,U,wC,I,E,E,E,K,C,E,G,E,E,E,E,C,O,E,C,E,E,Q,E,S,E,U,C,C,O,a,C,C,W,O,I,A,E,E,S,E,C,E,C,C,E,E,C,C,C,E,C,S,C,E,O,I,Q,S,C,C,C,E,E,I,C,C,E,E,E,E,E,G,E,E,E,E,C,C,C,S,E,C,C,C,E,G,K,C,E,E,C,C,E,C,I,K,Y,G,Q,O,C,E,K,C,C,E,I,C,E,G,E,C,C,E,C,E,C,E,C,M,E,C,E,C,C,E,C,E,C,E,C,C,S,E,C,E,E,O,E,C,S,E,C,E,E,Q,E,C,S,E,C,C,C,E,E,G,E,K,G,A,E,M,E,E,C,C,E,C,E,C,C,C,E,C,E,C,C,EAmCvB,SAAU,GAAuB,CAAiC,SACtE,AA3BQ,AAAwC,MAAxC,AA2BY,CA3BE,CAAC,OAAO,aAAA,CAAc,CA4BnC,EAEA,AArBL,SAA4C,CAAyB,E,O,G,I,C,U,W,I,E,E,E,E,O,G,I,C,S,C,E,O,E,K,E,K,EACnE,EAAS,EAAO,SAAhB,G,E,K,C,C,M,E,E,I,C,I,C,C,G,E,G,E,E,K,C,C,M,EAIsB,MAAA,CAAA,CAAA,OAAA,GAAA,GAAM,EAAO,IAAb,IAAmB,A,M,EACvC,GADI,EAAI,AAAN,CAAA,EAAkB,EAAA,IAAA,EAAA,EAAZ,IAAA,CAAE,EAAK,EAA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","sources":["<anon>","lib/dataconnection/StreamConnection/MsgPack.ts","node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs","node_modules/@msgpack/msgpack/src/decodeAsync.ts","node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs","node_modules/@msgpack/msgpack/src/Decoder.ts","node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs","node_modules/@msgpack/msgpack/src/utils/prettyByte.ts","node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs","node_modules/@msgpack/msgpack/src/ExtensionCodec.ts","node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs","node_modules/@msgpack/msgpack/src/ExtData.ts","node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs","node_modules/@msgpack/msgpack/src/timestamp.ts","node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs","node_modules/@msgpack/msgpack/src/DecodeError.ts","node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs","node_modules/@msgpack/msgpack/src/utils/int.ts","node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs","node_modules/@msgpack/msgpack/src/utils/utf8.ts","node_modules/@parcel/node-resolver-core/lib/_empty.js","node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs","node_modules/@msgpack/msgpack/src/utils/typedArrays.ts","node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs","node_modules/@msgpack/msgpack/src/CachedKeyDecoder.ts","node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs","node_modules/@msgpack/msgpack/src/utils/stream.ts","node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs","node_modules/@msgpack/msgpack/src/decode.ts","node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs","node_modules/@msgpack/msgpack/src/Encoder.ts","lib/dataconnection/StreamConnection/StreamConnection.ts","lib/logger.ts","lib/dataconnection/DataConnection.ts","lib/negotiator.ts","lib/enums.ts","lib/baseconnection.ts","lib/peerError.ts","node_modules/eventemitter3/index.js","lib/utils/randomToken.ts"],"sourcesContent":["function $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nvar $5dbeafcd6e23d52f$exports = {};\n\n$parcel$export($5dbeafcd6e23d52f$exports, \"decodeMultiStream\", () => $5dbeafcd6e23d52f$export$bf87d8a088c760fb);\nvar $e6c5ba1e7517ae08$exports = {};\n\n$parcel$export($e6c5ba1e7517ae08$exports, \"Decoder\", () => $e6c5ba1e7517ae08$export$f9de6ca0bc043724);\nfunction $31bcb34ba1ba037f$export$78406e843f5312da(byte) {\n    return \"\".concat(byte < 0 ? \"-\" : \"\", \"0x\").concat(Math.abs(byte).toString(16).padStart(2, \"0\"));\n}\n\n\n// ExtensionCodec to handle MessagePack extensions\n/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */ var $268a69da4c3a2b66$export$bcbeb236456bc779 = /** @class */ function() {\n    function ExtData(type, data) {\n        this.type = type;\n        this.data = data;\n    }\n    return ExtData;\n}();\n\n\n// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\nvar $8bb13aa6087251ac$exports = {};\n\n$parcel$export($8bb13aa6087251ac$exports, \"DecodeError\", () => $8bb13aa6087251ac$export$ef3eed12d06c0285);\nvar $8bb13aa6087251ac$var$__extends = undefined && undefined.__extends || function() {\n    var extendStatics = function(d, b) {\n        extendStatics = Object.setPrototypeOf || ({\n            __proto__: []\n        }) instanceof Array && function(d, b) {\n            d.__proto__ = b;\n        } || function(d, b) {\n            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n        };\n        return extendStatics(d, b);\n    };\n    return function(d, b) {\n        if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nvar $8bb13aa6087251ac$export$ef3eed12d06c0285 = /** @class */ function(_super) {\n    $8bb13aa6087251ac$var$__extends(DecodeError, _super);\n    function DecodeError(message) {\n        var _this = _super.call(this, message) || this;\n        // fix the prototype chain in a cross-platform way\n        var proto = Object.create(DecodeError.prototype);\n        Object.setPrototypeOf(_this, proto);\n        Object.defineProperty(_this, \"name\", {\n            configurable: true,\n            enumerable: false,\n            value: DecodeError.name\n        });\n        return _this;\n    }\n    return DecodeError;\n}(Error);\n\n\n// Integer Utility\nvar $518bfda92fef5c7f$export$3314b2c271c86d70 = 4294967295;\nfunction $518bfda92fef5c7f$export$20f71c4c8b0f96c3(view, offset, value) {\n    var high = value / 4294967296;\n    var low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nfunction $518bfda92fef5c7f$export$8532a5209571c04a(view, offset, value) {\n    var high = Math.floor(value / 4294967296);\n    var low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nfunction $518bfda92fef5c7f$export$69825c7adcc820c6(view, offset) {\n    var high = view.getInt32(offset);\n    var low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\nfunction $518bfda92fef5c7f$export$59a2dbf579ff9568(view, offset) {\n    var high = view.getUint32(offset);\n    var low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\n\n\nvar $90f42a47dc95aba0$export$f18369fc203f4e13 = -1;\nvar $90f42a47dc95aba0$var$TIMESTAMP32_MAX_SEC = 4294967295; // 32-bit unsigned int\nvar $90f42a47dc95aba0$var$TIMESTAMP64_MAX_SEC = 17179869183; // 34-bit unsigned int\nfunction $90f42a47dc95aba0$export$2fd05b828dd81159(_a) {\n    var sec = _a.sec, nsec = _a.nsec;\n    if (sec >= 0 && nsec >= 0 && sec <= $90f42a47dc95aba0$var$TIMESTAMP64_MAX_SEC) {\n        // Here sec >= 0 && nsec >= 0\n        if (nsec === 0 && sec <= $90f42a47dc95aba0$var$TIMESTAMP32_MAX_SEC) {\n            // timestamp 32 = { sec32 (unsigned) }\n            var rv = new Uint8Array(4);\n            var view = new DataView(rv.buffer);\n            view.setUint32(0, sec);\n            return rv;\n        } else {\n            // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n            var secHigh = sec / 0x100000000;\n            var secLow = sec & 0xffffffff;\n            var rv = new Uint8Array(8);\n            var view = new DataView(rv.buffer);\n            // nsec30 | secHigh2\n            view.setUint32(0, nsec << 2 | secHigh & 0x3);\n            // secLow32\n            view.setUint32(4, secLow);\n            return rv;\n        }\n    } else {\n        // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n        var rv = new Uint8Array(12);\n        var view = new DataView(rv.buffer);\n        view.setUint32(0, nsec);\n        (0, $518bfda92fef5c7f$export$8532a5209571c04a)(view, 4, sec);\n        return rv;\n    }\n}\nfunction $90f42a47dc95aba0$export$221d97b3b00b03c2(date) {\n    var msec = date.getTime();\n    var sec = Math.floor(msec / 1e3);\n    var nsec = (msec - sec * 1e3) * 1e6;\n    // Normalizes { sec, nsec } to ensure nsec is unsigned.\n    var nsecInSec = Math.floor(nsec / 1e9);\n    return {\n        sec: sec + nsecInSec,\n        nsec: nsec - nsecInSec * 1e9\n    };\n}\nfunction $90f42a47dc95aba0$export$32420f352fe0fc83(object) {\n    if (object instanceof Date) {\n        var timeSpec = $90f42a47dc95aba0$export$221d97b3b00b03c2(object);\n        return $90f42a47dc95aba0$export$2fd05b828dd81159(timeSpec);\n    } else return null;\n}\nfunction $90f42a47dc95aba0$export$abfc8800a5159711(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    // data may be 32, 64, or 96 bits\n    switch(data.byteLength){\n        case 4:\n            // timestamp 32 = { sec32 }\n            var sec = view.getUint32(0);\n            var nsec = 0;\n            return {\n                sec: sec,\n                nsec: nsec\n            };\n        case 8:\n            // timestamp 64 = { nsec30, sec34 }\n            var nsec30AndSecHigh2 = view.getUint32(0);\n            var secLow32 = view.getUint32(4);\n            var sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n            var nsec = nsec30AndSecHigh2 >>> 2;\n            return {\n                sec: sec,\n                nsec: nsec\n            };\n        case 12:\n            // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n            var sec = (0, $518bfda92fef5c7f$export$69825c7adcc820c6)(view, 4);\n            var nsec = view.getUint32(0);\n            return {\n                sec: sec,\n                nsec: nsec\n            };\n        default:\n            throw new (0, $8bb13aa6087251ac$exports.DecodeError)(\"Unrecognized data size for timestamp (expected 4, 8, or 12): \".concat(data.length));\n    }\n}\nfunction $90f42a47dc95aba0$export$80b8ff9315e4298f(data) {\n    var timeSpec = $90f42a47dc95aba0$export$abfc8800a5159711(data);\n    return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\nvar $90f42a47dc95aba0$export$8654479533463da1 = {\n    type: $90f42a47dc95aba0$export$f18369fc203f4e13,\n    encode: $90f42a47dc95aba0$export$32420f352fe0fc83,\n    decode: $90f42a47dc95aba0$export$80b8ff9315e4298f\n};\n\n\nvar $f1fa32c4c66b90ce$export$12677a794dbd89d7 = /** @class */ function() {\n    function ExtensionCodec() {\n        // built-in extensions\n        this.builtInEncoders = [];\n        this.builtInDecoders = [];\n        // custom extensions\n        this.encoders = [];\n        this.decoders = [];\n        this.register((0, $90f42a47dc95aba0$export$8654479533463da1));\n    }\n    ExtensionCodec.prototype.register = function(_a) {\n        var type = _a.type, encode = _a.encode, decode = _a.decode;\n        if (type >= 0) {\n            // custom extensions\n            this.encoders[type] = encode;\n            this.decoders[type] = decode;\n        } else {\n            // built-in extensions\n            var index = 1 + type;\n            this.builtInEncoders[index] = encode;\n            this.builtInDecoders[index] = decode;\n        }\n    };\n    ExtensionCodec.prototype.tryToEncode = function(object, context) {\n        // built-in extensions\n        for(var i = 0; i < this.builtInEncoders.length; i++){\n            var encodeExt = this.builtInEncoders[i];\n            if (encodeExt != null) {\n                var data = encodeExt(object, context);\n                if (data != null) {\n                    var type = -1 - i;\n                    return new (0, $268a69da4c3a2b66$export$bcbeb236456bc779)(type, data);\n                }\n            }\n        }\n        // custom extensions\n        for(var i = 0; i < this.encoders.length; i++){\n            var encodeExt = this.encoders[i];\n            if (encodeExt != null) {\n                var data = encodeExt(object, context);\n                if (data != null) {\n                    var type = i;\n                    return new (0, $268a69da4c3a2b66$export$bcbeb236456bc779)(type, data);\n                }\n            }\n        }\n        if (object instanceof (0, $268a69da4c3a2b66$export$bcbeb236456bc779)) // to keep ExtData as is\n        return object;\n        return null;\n    };\n    ExtensionCodec.prototype.decode = function(data, type, context) {\n        var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n        if (decodeExt) return decodeExt(data, type, context);\n        else // decode() does not fail, returns ExtData instead.\n        return new (0, $268a69da4c3a2b66$export$bcbeb236456bc779)(type, data);\n    };\n    ExtensionCodec.defaultCodec = new ExtensionCodec();\n    return ExtensionCodec;\n}();\n\n\n\n\nvar $43163e488488b0b2$exports = {};\n\"use strict\";\n\n\nvar $3f7790a221c2f3e5$var$_a, $3f7790a221c2f3e5$var$_b, $3f7790a221c2f3e5$var$_c;\nvar $3f7790a221c2f3e5$var$TEXT_ENCODING_AVAILABLE = (typeof $43163e488488b0b2$exports === \"undefined\" || (($3f7790a221c2f3e5$var$_a = $43163e488488b0b2$exports === null || $43163e488488b0b2$exports === void 0 ? void 0 : $43163e488488b0b2$exports.env) === null || $3f7790a221c2f3e5$var$_a === void 0 ? void 0 : $3f7790a221c2f3e5$var$_a[\"TEXT_ENCODING\"]) !== \"never\") && typeof TextEncoder !== \"undefined\" && typeof TextDecoder !== \"undefined\";\nfunction $3f7790a221c2f3e5$export$b61de95301265227(str) {\n    var strLength = str.length;\n    var byteLength = 0;\n    var pos = 0;\n    while(pos < strLength){\n        var value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            byteLength++;\n            continue;\n        } else if ((value & 0xfffff800) === 0) // 2-bytes\n        byteLength += 2;\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) // high surrogate\n            {\n                if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) // 3-byte\n            byteLength += 3;\n            else // 4-byte\n            byteLength += 4;\n        }\n    }\n    return byteLength;\n}\nfunction $3f7790a221c2f3e5$export$1042e4338f1ef853(str, output, outputOffset) {\n    var strLength = str.length;\n    var offset = outputOffset;\n    var pos = 0;\n    while(pos < strLength){\n        var value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            output[offset++] = value;\n            continue;\n        } else if ((value & 0xfffff800) === 0) // 2-bytes\n        output[offset++] = value >> 6 & 0x1f | 0xc0;\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) // high surrogate\n            {\n                if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                output[offset++] = value >> 12 & 0x0f | 0xe0;\n                output[offset++] = value >> 6 & 0x3f | 0x80;\n            } else {\n                // 4-byte\n                output[offset++] = value >> 18 & 0x07 | 0xf0;\n                output[offset++] = value >> 12 & 0x3f | 0x80;\n                output[offset++] = value >> 6 & 0x3f | 0x80;\n            }\n        }\n        output[offset++] = value & 0x3f | 0x80;\n    }\n}\nvar $3f7790a221c2f3e5$var$sharedTextEncoder = $3f7790a221c2f3e5$var$TEXT_ENCODING_AVAILABLE ? new TextEncoder() : undefined;\nvar $3f7790a221c2f3e5$export$ed34c0622b397238 = !$3f7790a221c2f3e5$var$TEXT_ENCODING_AVAILABLE ? (0, $518bfda92fef5c7f$export$3314b2c271c86d70) : typeof $43163e488488b0b2$exports !== \"undefined\" && (($3f7790a221c2f3e5$var$_b = $43163e488488b0b2$exports === null || $43163e488488b0b2$exports === void 0 ? void 0 : $43163e488488b0b2$exports.env) === null || $3f7790a221c2f3e5$var$_b === void 0 ? void 0 : $3f7790a221c2f3e5$var$_b[\"TEXT_ENCODING\"]) !== \"force\" ? 200 : 0;\nfunction $3f7790a221c2f3e5$var$utf8EncodeTEencode(str, output, outputOffset) {\n    output.set($3f7790a221c2f3e5$var$sharedTextEncoder.encode(str), outputOffset);\n}\nfunction $3f7790a221c2f3e5$var$utf8EncodeTEencodeInto(str, output, outputOffset) {\n    $3f7790a221c2f3e5$var$sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n}\nvar $3f7790a221c2f3e5$export$34cfdc82d430524 = ($3f7790a221c2f3e5$var$sharedTextEncoder === null || $3f7790a221c2f3e5$var$sharedTextEncoder === void 0 ? void 0 : $3f7790a221c2f3e5$var$sharedTextEncoder.encodeInto) ? $3f7790a221c2f3e5$var$utf8EncodeTEencodeInto : $3f7790a221c2f3e5$var$utf8EncodeTEencode;\nvar $3f7790a221c2f3e5$var$CHUNK_SIZE = 4096;\nfunction $3f7790a221c2f3e5$export$551117984c2adf4f(bytes, inputOffset, byteLength) {\n    var offset = inputOffset;\n    var end = offset + byteLength;\n    var units = [];\n    var result = \"\";\n    while(offset < end){\n        var byte1 = bytes[offset++];\n        if ((byte1 & 0x80) === 0) // 1 byte\n        units.push(byte1);\n        else if ((byte1 & 0xe0) === 0xc0) {\n            // 2 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            units.push((byte1 & 0x1f) << 6 | byte2);\n        } else if ((byte1 & 0xf0) === 0xe0) {\n            // 3 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            var byte3 = bytes[offset++] & 0x3f;\n            units.push((byte1 & 0x1f) << 12 | byte2 << 6 | byte3);\n        } else if ((byte1 & 0xf8) === 0xf0) {\n            // 4 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            var byte3 = bytes[offset++] & 0x3f;\n            var byte4 = bytes[offset++] & 0x3f;\n            var unit = (byte1 & 0x07) << 0x12 | byte2 << 0x0c | byte3 << 0x06 | byte4;\n            if (unit > 0xffff) {\n                unit -= 0x10000;\n                units.push(unit >>> 10 & 0x3ff | 0xd800);\n                unit = 0xdc00 | unit & 0x3ff;\n            }\n            units.push(unit);\n        } else units.push(byte1);\n        if (units.length >= $3f7790a221c2f3e5$var$CHUNK_SIZE) {\n            result += String.fromCharCode.apply(String, units);\n            units.length = 0;\n        }\n    }\n    if (units.length > 0) result += String.fromCharCode.apply(String, units);\n    return result;\n}\nvar $3f7790a221c2f3e5$var$sharedTextDecoder = $3f7790a221c2f3e5$var$TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;\nvar $3f7790a221c2f3e5$export$d866281c5a66d1ef = !$3f7790a221c2f3e5$var$TEXT_ENCODING_AVAILABLE ? (0, $518bfda92fef5c7f$export$3314b2c271c86d70) : typeof $43163e488488b0b2$exports !== \"undefined\" && (($3f7790a221c2f3e5$var$_c = $43163e488488b0b2$exports === null || $43163e488488b0b2$exports === void 0 ? void 0 : $43163e488488b0b2$exports.env) === null || $3f7790a221c2f3e5$var$_c === void 0 ? void 0 : $3f7790a221c2f3e5$var$_c[\"TEXT_DECODER\"]) !== \"force\" ? 200 : 0;\nfunction $3f7790a221c2f3e5$export$6ed79e41309992dc(bytes, inputOffset, byteLength) {\n    var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n    return $3f7790a221c2f3e5$var$sharedTextDecoder.decode(stringBytes);\n}\n\n\nfunction $e2b22818b7517d55$export$f8d669c2a17882f2(buffer) {\n    if (buffer instanceof Uint8Array) return buffer;\n    else if (ArrayBuffer.isView(buffer)) return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    else if (buffer instanceof ArrayBuffer) return new Uint8Array(buffer);\n    else // ArrayLike<number>\n    return Uint8Array.from(buffer);\n}\nfunction $e2b22818b7517d55$export$7277868462c1ba02(buffer) {\n    if (buffer instanceof ArrayBuffer) return new DataView(buffer);\n    var bufferView = $e2b22818b7517d55$export$f8d669c2a17882f2(buffer);\n    return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n}\n\n\n\nvar $a5b0b5bb55e8ea9d$var$DEFAULT_MAX_KEY_LENGTH = 16;\nvar $a5b0b5bb55e8ea9d$var$DEFAULT_MAX_LENGTH_PER_KEY = 16;\nvar $a5b0b5bb55e8ea9d$export$529b830450faf29c = /** @class */ function() {\n    function CachedKeyDecoder(maxKeyLength, maxLengthPerKey) {\n        if (maxKeyLength === void 0) maxKeyLength = $a5b0b5bb55e8ea9d$var$DEFAULT_MAX_KEY_LENGTH;\n        if (maxLengthPerKey === void 0) maxLengthPerKey = $a5b0b5bb55e8ea9d$var$DEFAULT_MAX_LENGTH_PER_KEY;\n        this.maxKeyLength = maxKeyLength;\n        this.maxLengthPerKey = maxLengthPerKey;\n        this.hit = 0;\n        this.miss = 0;\n        // avoid `new Array(N)`, which makes a sparse array,\n        // because a sparse array is typically slower than a non-sparse array.\n        this.caches = [];\n        for(var i = 0; i < this.maxKeyLength; i++)this.caches.push([]);\n    }\n    CachedKeyDecoder.prototype.canBeCached = function(byteLength) {\n        return byteLength > 0 && byteLength <= this.maxKeyLength;\n    };\n    CachedKeyDecoder.prototype.find = function(bytes, inputOffset, byteLength) {\n        var records = this.caches[byteLength - 1];\n        FIND_CHUNK: for(var _i = 0, records_1 = records; _i < records_1.length; _i++){\n            var record = records_1[_i];\n            var recordBytes = record.bytes;\n            for(var j = 0; j < byteLength; j++){\n                if (recordBytes[j] !== bytes[inputOffset + j]) continue FIND_CHUNK;\n            }\n            return record.str;\n        }\n        return null;\n    };\n    CachedKeyDecoder.prototype.store = function(bytes, value) {\n        var records = this.caches[bytes.length - 1];\n        var record = {\n            bytes: bytes,\n            str: value\n        };\n        if (records.length >= this.maxLengthPerKey) // `records` are full!\n        // Set `record` to an arbitrary position.\n        records[Math.random() * records.length | 0] = record;\n        else records.push(record);\n    };\n    CachedKeyDecoder.prototype.decode = function(bytes, inputOffset, byteLength) {\n        var cachedValue = this.find(bytes, inputOffset, byteLength);\n        if (cachedValue != null) {\n            this.hit++;\n            return cachedValue;\n        }\n        this.miss++;\n        var str = (0, $3f7790a221c2f3e5$export$551117984c2adf4f)(bytes, inputOffset, byteLength);\n        // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n        var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n        this.store(slicedCopyOfBytes, str);\n        return str;\n    };\n    return CachedKeyDecoder;\n}();\n\n\n\nvar $e6c5ba1e7517ae08$var$__awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar $e6c5ba1e7517ae08$var$__generator = undefined && undefined.__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nvar $e6c5ba1e7517ae08$var$__asyncValues = undefined && undefined.__asyncValues || function(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n};\nvar $e6c5ba1e7517ae08$var$__await = undefined && undefined.__await || function(v) {\n    return this instanceof $e6c5ba1e7517ae08$var$__await ? (this.v = v, this) : new $e6c5ba1e7517ae08$var$__await(v);\n};\nvar $e6c5ba1e7517ae08$var$__asyncGenerator = undefined && undefined.__asyncGenerator || function(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function verb(n) {\n        if (g[n]) i[n] = function(v) {\n            return new Promise(function(a, b) {\n                q.push([\n                    n,\n                    v,\n                    a,\n                    b\n                ]) > 1 || resume(n, v);\n            });\n        };\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof $e6c5ba1e7517ae08$var$__await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n};\nvar $e6c5ba1e7517ae08$var$isValidMapKeyType = function(key) {\n    var keyType = typeof key;\n    return keyType === \"string\" || keyType === \"number\";\n};\nvar $e6c5ba1e7517ae08$var$HEAD_BYTE_REQUIRED = -1;\nvar $e6c5ba1e7517ae08$var$EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nvar $e6c5ba1e7517ae08$var$EMPTY_BYTES = new Uint8Array($e6c5ba1e7517ae08$var$EMPTY_VIEW.buffer);\nvar $e6c5ba1e7517ae08$export$449c37eaf7093493 = function() {\n    try {\n        // IE11: The spec says it should throw RangeError,\n        // IE11: but in IE11 it throws TypeError.\n        $e6c5ba1e7517ae08$var$EMPTY_VIEW.getInt8(0);\n    } catch (e) {\n        return e.constructor;\n    }\n    throw new Error(\"never reached\");\n}();\nvar $e6c5ba1e7517ae08$var$MORE_DATA = new $e6c5ba1e7517ae08$export$449c37eaf7093493(\"Insufficient data\");\nvar $e6c5ba1e7517ae08$var$sharedCachedKeyDecoder = new (0, $a5b0b5bb55e8ea9d$export$529b830450faf29c)();\nvar $e6c5ba1e7517ae08$export$f9de6ca0bc043724 = /** @class */ function() {\n    function Decoder(extensionCodec, context, maxStrLength, maxBinLength, maxArrayLength, maxMapLength, maxExtLength, keyDecoder) {\n        if (extensionCodec === void 0) extensionCodec = (0, $f1fa32c4c66b90ce$export$12677a794dbd89d7).defaultCodec;\n        if (context === void 0) context = undefined;\n        if (maxStrLength === void 0) maxStrLength = (0, $518bfda92fef5c7f$export$3314b2c271c86d70);\n        if (maxBinLength === void 0) maxBinLength = (0, $518bfda92fef5c7f$export$3314b2c271c86d70);\n        if (maxArrayLength === void 0) maxArrayLength = (0, $518bfda92fef5c7f$export$3314b2c271c86d70);\n        if (maxMapLength === void 0) maxMapLength = (0, $518bfda92fef5c7f$export$3314b2c271c86d70);\n        if (maxExtLength === void 0) maxExtLength = (0, $518bfda92fef5c7f$export$3314b2c271c86d70);\n        if (keyDecoder === void 0) keyDecoder = $e6c5ba1e7517ae08$var$sharedCachedKeyDecoder;\n        this.extensionCodec = extensionCodec;\n        this.context = context;\n        this.maxStrLength = maxStrLength;\n        this.maxBinLength = maxBinLength;\n        this.maxArrayLength = maxArrayLength;\n        this.maxMapLength = maxMapLength;\n        this.maxExtLength = maxExtLength;\n        this.keyDecoder = keyDecoder;\n        this.totalPos = 0;\n        this.pos = 0;\n        this.view = $e6c5ba1e7517ae08$var$EMPTY_VIEW;\n        this.bytes = $e6c5ba1e7517ae08$var$EMPTY_BYTES;\n        this.headByte = $e6c5ba1e7517ae08$var$HEAD_BYTE_REQUIRED;\n        this.stack = [];\n    }\n    Decoder.prototype.reinitializeState = function() {\n        this.totalPos = 0;\n        this.headByte = $e6c5ba1e7517ae08$var$HEAD_BYTE_REQUIRED;\n        this.stack.length = 0;\n    // view, bytes, and pos will be re-initialized in setBuffer()\n    };\n    Decoder.prototype.setBuffer = function(buffer) {\n        this.bytes = (0, $e2b22818b7517d55$export$f8d669c2a17882f2)(buffer);\n        this.view = (0, $e2b22818b7517d55$export$7277868462c1ba02)(this.bytes);\n        this.pos = 0;\n    };\n    Decoder.prototype.appendBuffer = function(buffer) {\n        if (this.headByte === $e6c5ba1e7517ae08$var$HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) this.setBuffer(buffer);\n        else {\n            var remainingData = this.bytes.subarray(this.pos);\n            var newData = (0, $e2b22818b7517d55$export$f8d669c2a17882f2)(buffer);\n            // concat remainingData + newData\n            var newBuffer = new Uint8Array(remainingData.length + newData.length);\n            newBuffer.set(remainingData);\n            newBuffer.set(newData, remainingData.length);\n            this.setBuffer(newBuffer);\n        }\n    };\n    Decoder.prototype.hasRemaining = function(size) {\n        return this.view.byteLength - this.pos >= size;\n    };\n    Decoder.prototype.createExtraByteError = function(posToShow) {\n        var _a = this, view = _a.view, pos = _a.pos;\n        return new RangeError(\"Extra \".concat(view.byteLength - pos, \" of \").concat(view.byteLength, \" byte(s) found at buffer[\").concat(posToShow, \"]\"));\n    };\n    /**\n     * @throws {@link DecodeError}\n     * @throws {@link RangeError}\n     */ Decoder.prototype.decode = function(buffer) {\n        this.reinitializeState();\n        this.setBuffer(buffer);\n        var object = this.doDecodeSync();\n        if (this.hasRemaining(1)) throw this.createExtraByteError(this.pos);\n        return object;\n    };\n    Decoder.prototype.decodeMulti = function(buffer) {\n        return $e6c5ba1e7517ae08$var$__generator(this, function(_a) {\n            switch(_a.label){\n                case 0:\n                    this.reinitializeState();\n                    this.setBuffer(buffer);\n                    _a.label = 1;\n                case 1:\n                    if (!this.hasRemaining(1)) return [\n                        3 /*break*/ ,\n                        3\n                    ];\n                    return [\n                        4 /*yield*/ ,\n                        this.doDecodeSync()\n                    ];\n                case 2:\n                    _a.sent();\n                    return [\n                        3 /*break*/ ,\n                        1\n                    ];\n                case 3:\n                    return [\n                        2 /*return*/ \n                    ];\n            }\n        });\n    };\n    Decoder.prototype.decodeAsync = function(stream) {\n        var stream_1, stream_1_1;\n        var e_1, _a;\n        return $e6c5ba1e7517ae08$var$__awaiter(this, void 0, void 0, function() {\n            var decoded, object, buffer, e_1_1, _b, headByte, pos, totalPos;\n            return $e6c5ba1e7517ae08$var$__generator(this, function(_c) {\n                switch(_c.label){\n                    case 0:\n                        decoded = false;\n                        _c.label = 1;\n                    case 1:\n                        _c.trys.push([\n                            1,\n                            6,\n                            7,\n                            12\n                        ]);\n                        stream_1 = $e6c5ba1e7517ae08$var$__asyncValues(stream);\n                        _c.label = 2;\n                    case 2:\n                        return [\n                            4 /*yield*/ ,\n                            stream_1.next()\n                        ];\n                    case 3:\n                        if (!(stream_1_1 = _c.sent(), !stream_1_1.done)) return [\n                            3 /*break*/ ,\n                            5\n                        ];\n                        buffer = stream_1_1.value;\n                        if (decoded) throw this.createExtraByteError(this.totalPos);\n                        this.appendBuffer(buffer);\n                        try {\n                            object = this.doDecodeSync();\n                            decoded = true;\n                        } catch (e) {\n                            if (!(e instanceof $e6c5ba1e7517ae08$export$449c37eaf7093493)) throw e; // rethrow\n                        // fallthrough\n                        }\n                        this.totalPos += this.pos;\n                        _c.label = 4;\n                    case 4:\n                        return [\n                            3 /*break*/ ,\n                            2\n                        ];\n                    case 5:\n                        return [\n                            3 /*break*/ ,\n                            12\n                        ];\n                    case 6:\n                        e_1_1 = _c.sent();\n                        e_1 = {\n                            error: e_1_1\n                        };\n                        return [\n                            3 /*break*/ ,\n                            12\n                        ];\n                    case 7:\n                        _c.trys.push([\n                            7,\n                            ,\n                            10,\n                            11\n                        ]);\n                        if (!(stream_1_1 && !stream_1_1.done && (_a = stream_1.return))) return [\n                            3 /*break*/ ,\n                            9\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            _a.call(stream_1)\n                        ];\n                    case 8:\n                        _c.sent();\n                        _c.label = 9;\n                    case 9:\n                        return [\n                            3 /*break*/ ,\n                            11\n                        ];\n                    case 10:\n                        if (e_1) throw e_1.error;\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 11:\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 12:\n                        if (decoded) {\n                            if (this.hasRemaining(1)) throw this.createExtraByteError(this.totalPos);\n                            return [\n                                2 /*return*/ ,\n                                object\n                            ];\n                        }\n                        _b = this, headByte = _b.headByte, pos = _b.pos, totalPos = _b.totalPos;\n                        throw new RangeError(\"Insufficient data in parsing \".concat((0, $31bcb34ba1ba037f$export$78406e843f5312da)(headByte), \" at \").concat(totalPos, \" (\").concat(pos, \" in the current buffer)\"));\n                }\n            });\n        });\n    };\n    Decoder.prototype.decodeArrayStream = function(stream) {\n        return this.decodeMultiAsync(stream, true);\n    };\n    Decoder.prototype.decodeStream = function(stream) {\n        return this.decodeMultiAsync(stream, false);\n    };\n    Decoder.prototype.decodeMultiAsync = function(stream, isArray) {\n        return $e6c5ba1e7517ae08$var$__asyncGenerator(this, arguments, function decodeMultiAsync_1() {\n            var isArrayHeaderRequired, arrayItemsLeft, stream_2, stream_2_1, buffer, e_2, e_3_1;\n            var e_3, _a;\n            return $e6c5ba1e7517ae08$var$__generator(this, function(_b) {\n                switch(_b.label){\n                    case 0:\n                        isArrayHeaderRequired = isArray;\n                        arrayItemsLeft = -1;\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([\n                            1,\n                            13,\n                            14,\n                            19\n                        ]);\n                        stream_2 = $e6c5ba1e7517ae08$var$__asyncValues(stream);\n                        _b.label = 2;\n                    case 2:\n                        return [\n                            4 /*yield*/ ,\n                            $e6c5ba1e7517ae08$var$__await(stream_2.next())\n                        ];\n                    case 3:\n                        if (!(stream_2_1 = _b.sent(), !stream_2_1.done)) return [\n                            3 /*break*/ ,\n                            12\n                        ];\n                        buffer = stream_2_1.value;\n                        if (isArray && arrayItemsLeft === 0) throw this.createExtraByteError(this.totalPos);\n                        this.appendBuffer(buffer);\n                        if (isArrayHeaderRequired) {\n                            arrayItemsLeft = this.readArraySize();\n                            isArrayHeaderRequired = false;\n                            this.complete();\n                        }\n                        _b.label = 4;\n                    case 4:\n                        _b.trys.push([\n                            4,\n                            9,\n                            ,\n                            10\n                        ]);\n                        _b.label = 5;\n                    case 5:\n                        return [\n                            4 /*yield*/ ,\n                            $e6c5ba1e7517ae08$var$__await(this.doDecodeSync())\n                        ];\n                    case 6:\n                        return [\n                            4 /*yield*/ ,\n                            _b.sent()\n                        ];\n                    case 7:\n                        _b.sent();\n                        if (--arrayItemsLeft === 0) return [\n                            3 /*break*/ ,\n                            8\n                        ];\n                        return [\n                            3 /*break*/ ,\n                            5\n                        ];\n                    case 8:\n                        return [\n                            3 /*break*/ ,\n                            10\n                        ];\n                    case 9:\n                        e_2 = _b.sent();\n                        if (!(e_2 instanceof $e6c5ba1e7517ae08$export$449c37eaf7093493)) throw e_2; // rethrow\n                        return [\n                            3 /*break*/ ,\n                            10\n                        ];\n                    case 10:\n                        this.totalPos += this.pos;\n                        _b.label = 11;\n                    case 11:\n                        return [\n                            3 /*break*/ ,\n                            2\n                        ];\n                    case 12:\n                        return [\n                            3 /*break*/ ,\n                            19\n                        ];\n                    case 13:\n                        e_3_1 = _b.sent();\n                        e_3 = {\n                            error: e_3_1\n                        };\n                        return [\n                            3 /*break*/ ,\n                            19\n                        ];\n                    case 14:\n                        _b.trys.push([\n                            14,\n                            ,\n                            17,\n                            18\n                        ]);\n                        if (!(stream_2_1 && !stream_2_1.done && (_a = stream_2.return))) return [\n                            3 /*break*/ ,\n                            16\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            $e6c5ba1e7517ae08$var$__await(_a.call(stream_2))\n                        ];\n                    case 15:\n                        _b.sent();\n                        _b.label = 16;\n                    case 16:\n                        return [\n                            3 /*break*/ ,\n                            18\n                        ];\n                    case 17:\n                        if (e_3) throw e_3.error;\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 18:\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 19:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    Decoder.prototype.doDecodeSync = function() {\n        DECODE: while(true){\n            var headByte = this.readHeadByte();\n            var object = void 0;\n            if (headByte >= 0xe0) // negative fixint (111x xxxx) 0xe0 - 0xff\n            object = headByte - 0x100;\n            else if (headByte < 0xc0) {\n                if (headByte < 0x80) // positive fixint (0xxx xxxx) 0x00 - 0x7f\n                object = headByte;\n                else if (headByte < 0x90) {\n                    // fixmap (1000 xxxx) 0x80 - 0x8f\n                    var size = headByte - 0x80;\n                    if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                    } else object = {};\n                } else if (headByte < 0xa0) {\n                    // fixarray (1001 xxxx) 0x90 - 0x9f\n                    var size = headByte - 0x90;\n                    if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                    } else object = [];\n                } else {\n                    // fixstr (101x xxxx) 0xa0 - 0xbf\n                    var byteLength = headByte - 0xa0;\n                    object = this.decodeUtf8String(byteLength, 0);\n                }\n            } else if (headByte === 0xc0) // nil\n            object = null;\n            else if (headByte === 0xc2) // false\n            object = false;\n            else if (headByte === 0xc3) // true\n            object = true;\n            else if (headByte === 0xca) // float 32\n            object = this.readF32();\n            else if (headByte === 0xcb) // float 64\n            object = this.readF64();\n            else if (headByte === 0xcc) // uint 8\n            object = this.readU8();\n            else if (headByte === 0xcd) // uint 16\n            object = this.readU16();\n            else if (headByte === 0xce) // uint 32\n            object = this.readU32();\n            else if (headByte === 0xcf) // uint 64\n            object = this.readU64();\n            else if (headByte === 0xd0) // int 8\n            object = this.readI8();\n            else if (headByte === 0xd1) // int 16\n            object = this.readI16();\n            else if (headByte === 0xd2) // int 32\n            object = this.readI32();\n            else if (headByte === 0xd3) // int 64\n            object = this.readI64();\n            else if (headByte === 0xd9) {\n                // str 8\n                var byteLength = this.lookU8();\n                object = this.decodeUtf8String(byteLength, 1);\n            } else if (headByte === 0xda) {\n                // str 16\n                var byteLength = this.lookU16();\n                object = this.decodeUtf8String(byteLength, 2);\n            } else if (headByte === 0xdb) {\n                // str 32\n                var byteLength = this.lookU32();\n                object = this.decodeUtf8String(byteLength, 4);\n            } else if (headByte === 0xdc) {\n                // array 16\n                var size = this.readU16();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                } else object = [];\n            } else if (headByte === 0xdd) {\n                // array 32\n                var size = this.readU32();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                } else object = [];\n            } else if (headByte === 0xde) {\n                // map 16\n                var size = this.readU16();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                } else object = {};\n            } else if (headByte === 0xdf) {\n                // map 32\n                var size = this.readU32();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                } else object = {};\n            } else if (headByte === 0xc4) {\n                // bin 8\n                var size = this.lookU8();\n                object = this.decodeBinary(size, 1);\n            } else if (headByte === 0xc5) {\n                // bin 16\n                var size = this.lookU16();\n                object = this.decodeBinary(size, 2);\n            } else if (headByte === 0xc6) {\n                // bin 32\n                var size = this.lookU32();\n                object = this.decodeBinary(size, 4);\n            } else if (headByte === 0xd4) // fixext 1\n            object = this.decodeExtension(1, 0);\n            else if (headByte === 0xd5) // fixext 2\n            object = this.decodeExtension(2, 0);\n            else if (headByte === 0xd6) // fixext 4\n            object = this.decodeExtension(4, 0);\n            else if (headByte === 0xd7) // fixext 8\n            object = this.decodeExtension(8, 0);\n            else if (headByte === 0xd8) // fixext 16\n            object = this.decodeExtension(16, 0);\n            else if (headByte === 0xc7) {\n                // ext 8\n                var size = this.lookU8();\n                object = this.decodeExtension(size, 1);\n            } else if (headByte === 0xc8) {\n                // ext 16\n                var size = this.lookU16();\n                object = this.decodeExtension(size, 2);\n            } else if (headByte === 0xc9) {\n                // ext 32\n                var size = this.lookU32();\n                object = this.decodeExtension(size, 4);\n            } else throw new (0, $8bb13aa6087251ac$exports.DecodeError)(\"Unrecognized type byte: \".concat((0, $31bcb34ba1ba037f$export$78406e843f5312da)(headByte)));\n            this.complete();\n            var stack = this.stack;\n            while(stack.length > 0){\n                // arrays and maps\n                var state = stack[stack.length - 1];\n                if (state.type === 0 /* State.ARRAY */ ) {\n                    state.array[state.position] = object;\n                    state.position++;\n                    if (state.position === state.size) {\n                        stack.pop();\n                        object = state.array;\n                    } else continue DECODE;\n                } else if (state.type === 1 /* State.MAP_KEY */ ) {\n                    if (!$e6c5ba1e7517ae08$var$isValidMapKeyType(object)) throw new (0, $8bb13aa6087251ac$exports.DecodeError)(\"The type of key must be string or number but \" + typeof object);\n                    if (object === \"__proto__\") throw new (0, $8bb13aa6087251ac$exports.DecodeError)(\"The key __proto__ is not allowed\");\n                    state.key = object;\n                    state.type = 2 /* State.MAP_VALUE */ ;\n                    continue DECODE;\n                } else {\n                    // it must be `state.type === State.MAP_VALUE` here\n                    state.map[state.key] = object;\n                    state.readCount++;\n                    if (state.readCount === state.size) {\n                        stack.pop();\n                        object = state.map;\n                    } else {\n                        state.key = null;\n                        state.type = 1 /* State.MAP_KEY */ ;\n                        continue DECODE;\n                    }\n                }\n            }\n            return object;\n        }\n    };\n    Decoder.prototype.readHeadByte = function() {\n        if (this.headByte === $e6c5ba1e7517ae08$var$HEAD_BYTE_REQUIRED) this.headByte = this.readU8();\n        return this.headByte;\n    };\n    Decoder.prototype.complete = function() {\n        this.headByte = $e6c5ba1e7517ae08$var$HEAD_BYTE_REQUIRED;\n    };\n    Decoder.prototype.readArraySize = function() {\n        var headByte = this.readHeadByte();\n        switch(headByte){\n            case 0xdc:\n                return this.readU16();\n            case 0xdd:\n                return this.readU32();\n            default:\n                if (headByte < 0xa0) return headByte - 0x90;\n                else throw new (0, $8bb13aa6087251ac$exports.DecodeError)(\"Unrecognized array type byte: \".concat((0, $31bcb34ba1ba037f$export$78406e843f5312da)(headByte)));\n        }\n    };\n    Decoder.prototype.pushMapState = function(size) {\n        if (size > this.maxMapLength) throw new (0, $8bb13aa6087251ac$exports.DecodeError)(\"Max length exceeded: map length (\".concat(size, \") > maxMapLengthLength (\").concat(this.maxMapLength, \")\"));\n        this.stack.push({\n            type: 1 /* State.MAP_KEY */ ,\n            size: size,\n            key: null,\n            readCount: 0,\n            map: {}\n        });\n    };\n    Decoder.prototype.pushArrayState = function(size) {\n        if (size > this.maxArrayLength) throw new (0, $8bb13aa6087251ac$exports.DecodeError)(\"Max length exceeded: array length (\".concat(size, \") > maxArrayLength (\").concat(this.maxArrayLength, \")\"));\n        this.stack.push({\n            type: 0 /* State.ARRAY */ ,\n            size: size,\n            array: new Array(size),\n            position: 0\n        });\n    };\n    Decoder.prototype.decodeUtf8String = function(byteLength, headerOffset) {\n        var _a;\n        if (byteLength > this.maxStrLength) throw new (0, $8bb13aa6087251ac$exports.DecodeError)(\"Max length exceeded: UTF-8 byte length (\".concat(byteLength, \") > maxStrLength (\").concat(this.maxStrLength, \")\"));\n        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) throw $e6c5ba1e7517ae08$var$MORE_DATA;\n        var offset = this.pos + headerOffset;\n        var object;\n        if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n        else if (byteLength > (0, $3f7790a221c2f3e5$export$d866281c5a66d1ef)) object = (0, $3f7790a221c2f3e5$export$6ed79e41309992dc)(this.bytes, offset, byteLength);\n        else object = (0, $3f7790a221c2f3e5$export$551117984c2adf4f)(this.bytes, offset, byteLength);\n        this.pos += headerOffset + byteLength;\n        return object;\n    };\n    Decoder.prototype.stateIsMapKey = function() {\n        if (this.stack.length > 0) {\n            var state = this.stack[this.stack.length - 1];\n            return state.type === 1 /* State.MAP_KEY */ ;\n        }\n        return false;\n    };\n    Decoder.prototype.decodeBinary = function(byteLength, headOffset) {\n        if (byteLength > this.maxBinLength) throw new (0, $8bb13aa6087251ac$exports.DecodeError)(\"Max length exceeded: bin length (\".concat(byteLength, \") > maxBinLength (\").concat(this.maxBinLength, \")\"));\n        if (!this.hasRemaining(byteLength + headOffset)) throw $e6c5ba1e7517ae08$var$MORE_DATA;\n        var offset = this.pos + headOffset;\n        var object = this.bytes.subarray(offset, offset + byteLength);\n        this.pos += headOffset + byteLength;\n        return object;\n    };\n    Decoder.prototype.decodeExtension = function(size, headOffset) {\n        if (size > this.maxExtLength) throw new (0, $8bb13aa6087251ac$exports.DecodeError)(\"Max length exceeded: ext length (\".concat(size, \") > maxExtLength (\").concat(this.maxExtLength, \")\"));\n        var extType = this.view.getInt8(this.pos + headOffset);\n        var data = this.decodeBinary(size, headOffset + 1 /* extType */ );\n        return this.extensionCodec.decode(data, extType, this.context);\n    };\n    Decoder.prototype.lookU8 = function() {\n        return this.view.getUint8(this.pos);\n    };\n    Decoder.prototype.lookU16 = function() {\n        return this.view.getUint16(this.pos);\n    };\n    Decoder.prototype.lookU32 = function() {\n        return this.view.getUint32(this.pos);\n    };\n    Decoder.prototype.readU8 = function() {\n        var value = this.view.getUint8(this.pos);\n        this.pos++;\n        return value;\n    };\n    Decoder.prototype.readI8 = function() {\n        var value = this.view.getInt8(this.pos);\n        this.pos++;\n        return value;\n    };\n    Decoder.prototype.readU16 = function() {\n        var value = this.view.getUint16(this.pos);\n        this.pos += 2;\n        return value;\n    };\n    Decoder.prototype.readI16 = function() {\n        var value = this.view.getInt16(this.pos);\n        this.pos += 2;\n        return value;\n    };\n    Decoder.prototype.readU32 = function() {\n        var value = this.view.getUint32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readI32 = function() {\n        var value = this.view.getInt32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readU64 = function() {\n        var value = (0, $518bfda92fef5c7f$export$59a2dbf579ff9568)(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readI64 = function() {\n        var value = (0, $518bfda92fef5c7f$export$69825c7adcc820c6)(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readF32 = function() {\n        var value = this.view.getFloat32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readF64 = function() {\n        var value = this.view.getFloat64(this.pos);\n        this.pos += 8;\n        return value;\n    };\n    return Decoder;\n}();\n\n\nvar $de4ae0b6ff372b32$exports = {};\n\n$parcel$export($de4ae0b6ff372b32$exports, \"ensureAsyncIterable\", () => $de4ae0b6ff372b32$export$bf99ef56e8bd104);\n// utility for whatwg streams\nvar $de4ae0b6ff372b32$var$__generator = undefined && undefined.__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nvar $de4ae0b6ff372b32$var$__await = undefined && undefined.__await || function(v) {\n    return this instanceof $de4ae0b6ff372b32$var$__await ? (this.v = v, this) : new $de4ae0b6ff372b32$var$__await(v);\n};\nvar $de4ae0b6ff372b32$var$__asyncGenerator = undefined && undefined.__asyncGenerator || function(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function verb(n) {\n        if (g[n]) i[n] = function(v) {\n            return new Promise(function(a, b) {\n                q.push([\n                    n,\n                    v,\n                    a,\n                    b\n                ]) > 1 || resume(n, v);\n            });\n        };\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof $de4ae0b6ff372b32$var$__await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n};\nfunction $de4ae0b6ff372b32$export$edb10ab8dd75a915(object) {\n    return object[Symbol.asyncIterator] != null;\n}\nfunction $de4ae0b6ff372b32$var$assertNonNull(value) {\n    if (value == null) throw new Error(\"Assertion Failure: value must not be null nor undefined\");\n}\nfunction $de4ae0b6ff372b32$export$f62cf0e66867a58e(stream) {\n    return $de4ae0b6ff372b32$var$__asyncGenerator(this, arguments, function asyncIterableFromStream_1() {\n        var reader, _a, done, value;\n        return $de4ae0b6ff372b32$var$__generator(this, function(_b) {\n            switch(_b.label){\n                case 0:\n                    reader = stream.getReader();\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([\n                        1,\n                        ,\n                        9,\n                        10\n                    ]);\n                    _b.label = 2;\n                case 2:\n                    return [\n                        4 /*yield*/ ,\n                        $de4ae0b6ff372b32$var$__await(reader.read())\n                    ];\n                case 3:\n                    _a = _b.sent(), done = _a.done, value = _a.value;\n                    if (!done) return [\n                        3 /*break*/ ,\n                        5\n                    ];\n                    return [\n                        4 /*yield*/ ,\n                        $de4ae0b6ff372b32$var$__await(void 0)\n                    ];\n                case 4:\n                    return [\n                        2 /*return*/ ,\n                        _b.sent()\n                    ];\n                case 5:\n                    $de4ae0b6ff372b32$var$assertNonNull(value);\n                    return [\n                        4 /*yield*/ ,\n                        $de4ae0b6ff372b32$var$__await(value)\n                    ];\n                case 6:\n                    return [\n                        4 /*yield*/ ,\n                        _b.sent()\n                    ];\n                case 7:\n                    _b.sent();\n                    return [\n                        3 /*break*/ ,\n                        2\n                    ];\n                case 8:\n                    return [\n                        3 /*break*/ ,\n                        10\n                    ];\n                case 9:\n                    reader.releaseLock();\n                    return [\n                        7 /*endfinally*/ \n                    ];\n                case 10:\n                    return [\n                        2 /*return*/ \n                    ];\n            }\n        });\n    });\n}\nfunction $de4ae0b6ff372b32$export$bf99ef56e8bd104(streamLike) {\n    if ($de4ae0b6ff372b32$export$edb10ab8dd75a915(streamLike)) return streamLike;\n    else return $de4ae0b6ff372b32$export$f62cf0e66867a58e(streamLike);\n}\n\n\n\nvar $79f3aa6fd9a8a1cb$export$ca6ec972f712a9eb = {};\nfunction $79f3aa6fd9a8a1cb$export$2f872c0f2117be69(buffer, options) {\n    if (options === void 0) options = $79f3aa6fd9a8a1cb$export$ca6ec972f712a9eb;\n    var decoder = new (0, $e6c5ba1e7517ae08$exports.Decoder)(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decode(buffer);\n}\nfunction $79f3aa6fd9a8a1cb$export$43cc91859d9fdc54(buffer, options) {\n    if (options === void 0) options = $79f3aa6fd9a8a1cb$export$ca6ec972f712a9eb;\n    var decoder = new (0, $e6c5ba1e7517ae08$exports.Decoder)(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decodeMulti(buffer);\n}\n\n\nvar $5dbeafcd6e23d52f$var$__awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar $5dbeafcd6e23d52f$var$__generator = undefined && undefined.__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nfunction $5dbeafcd6e23d52f$export$e4c183687a6ff9b(streamLike, options) {\n    if (options === void 0) options = (0, $79f3aa6fd9a8a1cb$export$ca6ec972f712a9eb);\n    return $5dbeafcd6e23d52f$var$__awaiter(this, void 0, void 0, function() {\n        var stream, decoder;\n        return $5dbeafcd6e23d52f$var$__generator(this, function(_a) {\n            stream = (0, $de4ae0b6ff372b32$exports.ensureAsyncIterable)(streamLike);\n            decoder = new (0, $e6c5ba1e7517ae08$exports.Decoder)(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return [\n                2 /*return*/ ,\n                decoder.decodeAsync(stream)\n            ];\n        });\n    });\n}\nfunction $5dbeafcd6e23d52f$export$b1b94ac44d9853a4(streamLike, options) {\n    if (options === void 0) options = (0, $79f3aa6fd9a8a1cb$export$ca6ec972f712a9eb);\n    var stream = (0, $de4ae0b6ff372b32$exports.ensureAsyncIterable)(streamLike);\n    var decoder = new (0, $e6c5ba1e7517ae08$exports.Decoder)(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decodeArrayStream(stream);\n}\nfunction $5dbeafcd6e23d52f$export$bf87d8a088c760fb(streamLike, options) {\n    if (options === void 0) options = (0, $79f3aa6fd9a8a1cb$export$ca6ec972f712a9eb);\n    var stream = (0, $de4ae0b6ff372b32$exports.ensureAsyncIterable)(streamLike);\n    var decoder = new (0, $e6c5ba1e7517ae08$exports.Decoder)(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decodeStream(stream);\n}\nfunction $5dbeafcd6e23d52f$export$7fb0f205e4fd0bbe(streamLike, options) {\n    if (options === void 0) options = (0, $79f3aa6fd9a8a1cb$export$ca6ec972f712a9eb);\n    return $5dbeafcd6e23d52f$export$bf87d8a088c760fb(streamLike, options);\n}\n\n\n\n\n\nvar $c94702bf03c532e7$export$2c6de1218fe0e46d = 100;\nvar $c94702bf03c532e7$export$29659805a45f979c = 2048;\nvar $c94702bf03c532e7$export$a50aceb0e02a00aa = /** @class */ function() {\n    function Encoder(extensionCodec, context, maxDepth, initialBufferSize, sortKeys, forceFloat32, ignoreUndefined, forceIntegerToFloat) {\n        if (extensionCodec === void 0) extensionCodec = (0, $f1fa32c4c66b90ce$export$12677a794dbd89d7).defaultCodec;\n        if (context === void 0) context = undefined;\n        if (maxDepth === void 0) maxDepth = $c94702bf03c532e7$export$2c6de1218fe0e46d;\n        if (initialBufferSize === void 0) initialBufferSize = $c94702bf03c532e7$export$29659805a45f979c;\n        if (sortKeys === void 0) sortKeys = false;\n        if (forceFloat32 === void 0) forceFloat32 = false;\n        if (ignoreUndefined === void 0) ignoreUndefined = false;\n        if (forceIntegerToFloat === void 0) forceIntegerToFloat = false;\n        this.extensionCodec = extensionCodec;\n        this.context = context;\n        this.maxDepth = maxDepth;\n        this.initialBufferSize = initialBufferSize;\n        this.sortKeys = sortKeys;\n        this.forceFloat32 = forceFloat32;\n        this.ignoreUndefined = ignoreUndefined;\n        this.forceIntegerToFloat = forceIntegerToFloat;\n        this.pos = 0;\n        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n        this.bytes = new Uint8Array(this.view.buffer);\n    }\n    Encoder.prototype.reinitializeState = function() {\n        this.pos = 0;\n    };\n    /**\n     * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.\n     *\n     * @returns Encodes the object and returns a shared reference the encoder's internal buffer.\n     */ Encoder.prototype.encodeSharedRef = function(object) {\n        this.reinitializeState();\n        this.doEncode(object, 1);\n        return this.bytes.subarray(0, this.pos);\n    };\n    /**\n     * @returns Encodes the object and returns a copy of the encoder's internal buffer.\n     */ Encoder.prototype.encode = function(object) {\n        this.reinitializeState();\n        this.doEncode(object, 1);\n        return this.bytes.slice(0, this.pos);\n    };\n    Encoder.prototype.doEncode = function(object, depth) {\n        if (depth > this.maxDepth) throw new Error(\"Too deep objects in depth \".concat(depth));\n        if (object == null) this.encodeNil();\n        else if (typeof object === \"boolean\") this.encodeBoolean(object);\n        else if (typeof object === \"number\") this.encodeNumber(object);\n        else if (typeof object === \"string\") this.encodeString(object);\n        else this.encodeObject(object, depth);\n    };\n    Encoder.prototype.ensureBufferSizeToWrite = function(sizeToWrite) {\n        var requiredSize = this.pos + sizeToWrite;\n        if (this.view.byteLength < requiredSize) this.resizeBuffer(requiredSize * 2);\n    };\n    Encoder.prototype.resizeBuffer = function(newSize) {\n        var newBuffer = new ArrayBuffer(newSize);\n        var newBytes = new Uint8Array(newBuffer);\n        var newView = new DataView(newBuffer);\n        newBytes.set(this.bytes);\n        this.view = newView;\n        this.bytes = newBytes;\n    };\n    Encoder.prototype.encodeNil = function() {\n        this.writeU8(0xc0);\n    };\n    Encoder.prototype.encodeBoolean = function(object) {\n        if (object === false) this.writeU8(0xc2);\n        else this.writeU8(0xc3);\n    };\n    Encoder.prototype.encodeNumber = function(object) {\n        if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {\n            if (object >= 0) {\n                if (object < 0x80) // positive fixint\n                this.writeU8(object);\n                else if (object < 0x100) {\n                    // uint 8\n                    this.writeU8(0xcc);\n                    this.writeU8(object);\n                } else if (object < 0x10000) {\n                    // uint 16\n                    this.writeU8(0xcd);\n                    this.writeU16(object);\n                } else if (object < 0x100000000) {\n                    // uint 32\n                    this.writeU8(0xce);\n                    this.writeU32(object);\n                } else {\n                    // uint 64\n                    this.writeU8(0xcf);\n                    this.writeU64(object);\n                }\n            } else {\n                if (object >= -32) // negative fixint\n                this.writeU8(0xe0 | object + 0x20);\n                else if (object >= -128) {\n                    // int 8\n                    this.writeU8(0xd0);\n                    this.writeI8(object);\n                } else if (object >= -32768) {\n                    // int 16\n                    this.writeU8(0xd1);\n                    this.writeI16(object);\n                } else if (object >= -2147483648) {\n                    // int 32\n                    this.writeU8(0xd2);\n                    this.writeI32(object);\n                } else {\n                    // int 64\n                    this.writeU8(0xd3);\n                    this.writeI64(object);\n                }\n            }\n        } else // non-integer numbers\n        if (this.forceFloat32) {\n            // float 32\n            this.writeU8(0xca);\n            this.writeF32(object);\n        } else {\n            // float 64\n            this.writeU8(0xcb);\n            this.writeF64(object);\n        }\n    };\n    Encoder.prototype.writeStringHeader = function(byteLength) {\n        if (byteLength < 32) // fixstr\n        this.writeU8(0xa0 + byteLength);\n        else if (byteLength < 0x100) {\n            // str 8\n            this.writeU8(0xd9);\n            this.writeU8(byteLength);\n        } else if (byteLength < 0x10000) {\n            // str 16\n            this.writeU8(0xda);\n            this.writeU16(byteLength);\n        } else if (byteLength < 0x100000000) {\n            // str 32\n            this.writeU8(0xdb);\n            this.writeU32(byteLength);\n        } else throw new Error(\"Too long string: \".concat(byteLength, \" bytes in UTF-8\"));\n    };\n    Encoder.prototype.encodeString = function(object) {\n        var maxHeaderSize = 5;\n        var strLength = object.length;\n        if (strLength > (0, $3f7790a221c2f3e5$export$ed34c0622b397238)) {\n            var byteLength = (0, $3f7790a221c2f3e5$export$b61de95301265227)(object);\n            this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n            this.writeStringHeader(byteLength);\n            (0, $3f7790a221c2f3e5$export$34cfdc82d430524)(object, this.bytes, this.pos);\n            this.pos += byteLength;\n        } else {\n            var byteLength = (0, $3f7790a221c2f3e5$export$b61de95301265227)(object);\n            this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n            this.writeStringHeader(byteLength);\n            (0, $3f7790a221c2f3e5$export$1042e4338f1ef853)(object, this.bytes, this.pos);\n            this.pos += byteLength;\n        }\n    };\n    Encoder.prototype.encodeObject = function(object, depth) {\n        // try to encode objects with custom codec first of non-primitives\n        var ext = this.extensionCodec.tryToEncode(object, this.context);\n        if (ext != null) this.encodeExtension(ext);\n        else if (Array.isArray(object)) this.encodeArray(object, depth);\n        else if (ArrayBuffer.isView(object)) this.encodeBinary(object);\n        else if (typeof object === \"object\") this.encodeMap(object, depth);\n        else // symbol, function and other special object come here unless extensionCodec handles them.\n        throw new Error(\"Unrecognized object: \".concat(Object.prototype.toString.apply(object)));\n    };\n    Encoder.prototype.encodeBinary = function(object) {\n        var size = object.byteLength;\n        if (size < 0x100) {\n            // bin 8\n            this.writeU8(0xc4);\n            this.writeU8(size);\n        } else if (size < 0x10000) {\n            // bin 16\n            this.writeU8(0xc5);\n            this.writeU16(size);\n        } else if (size < 0x100000000) {\n            // bin 32\n            this.writeU8(0xc6);\n            this.writeU32(size);\n        } else throw new Error(\"Too large binary: \".concat(size));\n        var bytes = (0, $e2b22818b7517d55$export$f8d669c2a17882f2)(object);\n        this.writeU8a(bytes);\n    };\n    Encoder.prototype.encodeArray = function(object, depth) {\n        var size = object.length;\n        if (size < 16) // fixarray\n        this.writeU8(0x90 + size);\n        else if (size < 0x10000) {\n            // array 16\n            this.writeU8(0xdc);\n            this.writeU16(size);\n        } else if (size < 0x100000000) {\n            // array 32\n            this.writeU8(0xdd);\n            this.writeU32(size);\n        } else throw new Error(\"Too large array: \".concat(size));\n        for(var _i = 0, object_1 = object; _i < object_1.length; _i++){\n            var item = object_1[_i];\n            this.doEncode(item, depth + 1);\n        }\n    };\n    Encoder.prototype.countWithoutUndefined = function(object, keys) {\n        var count = 0;\n        for(var _i = 0, keys_1 = keys; _i < keys_1.length; _i++){\n            var key = keys_1[_i];\n            if (object[key] !== undefined) count++;\n        }\n        return count;\n    };\n    Encoder.prototype.encodeMap = function(object, depth) {\n        var keys = Object.keys(object);\n        if (this.sortKeys) keys.sort();\n        var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n        if (size < 16) // fixmap\n        this.writeU8(0x80 + size);\n        else if (size < 0x10000) {\n            // map 16\n            this.writeU8(0xde);\n            this.writeU16(size);\n        } else if (size < 0x100000000) {\n            // map 32\n            this.writeU8(0xdf);\n            this.writeU32(size);\n        } else throw new Error(\"Too large map object: \".concat(size));\n        for(var _i = 0, keys_2 = keys; _i < keys_2.length; _i++){\n            var key = keys_2[_i];\n            var value = object[key];\n            if (!(this.ignoreUndefined && value === undefined)) {\n                this.encodeString(key);\n                this.doEncode(value, depth + 1);\n            }\n        }\n    };\n    Encoder.prototype.encodeExtension = function(ext) {\n        var size = ext.data.length;\n        if (size === 1) // fixext 1\n        this.writeU8(0xd4);\n        else if (size === 2) // fixext 2\n        this.writeU8(0xd5);\n        else if (size === 4) // fixext 4\n        this.writeU8(0xd6);\n        else if (size === 8) // fixext 8\n        this.writeU8(0xd7);\n        else if (size === 16) // fixext 16\n        this.writeU8(0xd8);\n        else if (size < 0x100) {\n            // ext 8\n            this.writeU8(0xc7);\n            this.writeU8(size);\n        } else if (size < 0x10000) {\n            // ext 16\n            this.writeU8(0xc8);\n            this.writeU16(size);\n        } else if (size < 0x100000000) {\n            // ext 32\n            this.writeU8(0xc9);\n            this.writeU32(size);\n        } else throw new Error(\"Too large extension object: \".concat(size));\n        this.writeI8(ext.type);\n        this.writeU8a(ext.data);\n    };\n    Encoder.prototype.writeU8 = function(value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setUint8(this.pos, value);\n        this.pos++;\n    };\n    Encoder.prototype.writeU8a = function(values) {\n        var size = values.length;\n        this.ensureBufferSizeToWrite(size);\n        this.bytes.set(values, this.pos);\n        this.pos += size;\n    };\n    Encoder.prototype.writeI8 = function(value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setInt8(this.pos, value);\n        this.pos++;\n    };\n    Encoder.prototype.writeU16 = function(value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setUint16(this.pos, value);\n        this.pos += 2;\n    };\n    Encoder.prototype.writeI16 = function(value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setInt16(this.pos, value);\n        this.pos += 2;\n    };\n    Encoder.prototype.writeU32 = function(value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setUint32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeI32 = function(value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setInt32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeF32 = function(value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setFloat32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeF64 = function(value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setFloat64(this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeU64 = function(value) {\n        this.ensureBufferSizeToWrite(8);\n        (0, $518bfda92fef5c7f$export$20f71c4c8b0f96c3)(this.view, this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeI64 = function(value) {\n        this.ensureBufferSizeToWrite(8);\n        (0, $518bfda92fef5c7f$export$8532a5209571c04a)(this.view, this.pos, value);\n        this.pos += 8;\n    };\n    return Encoder;\n}();\n\n\nconst $55e90223fe532944$var$LOG_PREFIX = \"PeerJS: \";\nvar $55e90223fe532944$export$243e62d78d3b544d;\n(function(LogLevel) {\n    LogLevel[LogLevel[/**\n\t * Prints no logs.\n\t */ \"Disabled\"] = 0] = \"Disabled\";\n    LogLevel[LogLevel[/**\n\t * Prints only errors.\n\t */ \"Errors\"] = 1] = \"Errors\";\n    LogLevel[LogLevel[/**\n\t * Prints errors and warnings.\n\t */ \"Warnings\"] = 2] = \"Warnings\";\n    LogLevel[LogLevel[/**\n\t * Prints all logs.\n\t */ \"All\"] = 3] = \"All\";\n})($55e90223fe532944$export$243e62d78d3b544d || ($55e90223fe532944$export$243e62d78d3b544d = {}));\nclass $55e90223fe532944$var$Logger {\n    get logLevel() {\n        return this._logLevel;\n    }\n    set logLevel(logLevel) {\n        this._logLevel = logLevel;\n    }\n    log(...args) {\n        if (this._logLevel >= $55e90223fe532944$export$243e62d78d3b544d.All) this._print($55e90223fe532944$export$243e62d78d3b544d.All, ...args);\n    }\n    warn(...args) {\n        if (this._logLevel >= $55e90223fe532944$export$243e62d78d3b544d.Warnings) this._print($55e90223fe532944$export$243e62d78d3b544d.Warnings, ...args);\n    }\n    error(...args) {\n        if (this._logLevel >= $55e90223fe532944$export$243e62d78d3b544d.Errors) this._print($55e90223fe532944$export$243e62d78d3b544d.Errors, ...args);\n    }\n    setLogFunction(fn) {\n        this._print = fn;\n    }\n    _print(logLevel, ...rest) {\n        const copy = [\n            $55e90223fe532944$var$LOG_PREFIX,\n            ...rest\n        ];\n        for(const i in copy)if (copy[i] instanceof Error) copy[i] = \"(\" + copy[i].name + \") \" + copy[i].message;\n        if (logLevel >= $55e90223fe532944$export$243e62d78d3b544d.All) console.log(...copy);\n        else if (logLevel >= $55e90223fe532944$export$243e62d78d3b544d.Warnings) console.warn(\"WARNING\", ...copy);\n        else if (logLevel >= $55e90223fe532944$export$243e62d78d3b544d.Errors) console.error(\"ERROR\", ...copy);\n    }\n    constructor(){\n        this._logLevel = $55e90223fe532944$export$243e62d78d3b544d.Disabled;\n    }\n}\nvar $55e90223fe532944$export$2e2bcd8739ae039 = new $55e90223fe532944$var$Logger();\n\n\n\n\nvar $e07633d19f7426e9$export$3157d57b4135e3bc;\n(function(ConnectionType) {\n    ConnectionType[\"Data\"] = \"data\";\n    ConnectionType[\"Media\"] = \"media\";\n})($e07633d19f7426e9$export$3157d57b4135e3bc || ($e07633d19f7426e9$export$3157d57b4135e3bc = {}));\nvar $e07633d19f7426e9$export$9547aaa2e39030ff;\n(function(PeerErrorType) {\n    PeerErrorType[/**\n\t * The client's browser does not support some or all WebRTC features that you are trying to use.\n\t */ \"BrowserIncompatible\"] = \"browser-incompatible\";\n    PeerErrorType[/**\n\t * You've already disconnected this peer from the server and can no longer make any new connections on it.\n\t */ \"Disconnected\"] = \"disconnected\";\n    PeerErrorType[/**\n\t * The ID passed into the Peer constructor contains illegal characters.\n\t */ \"InvalidID\"] = \"invalid-id\";\n    PeerErrorType[/**\n\t * The API key passed into the Peer constructor contains illegal characters or is not in the system (cloud server only).\n\t */ \"InvalidKey\"] = \"invalid-key\";\n    PeerErrorType[/**\n\t * Lost or cannot establish a connection to the signalling server.\n\t */ \"Network\"] = \"network\";\n    PeerErrorType[/**\n\t * The peer you're trying to connect to does not exist.\n\t */ \"PeerUnavailable\"] = \"peer-unavailable\";\n    PeerErrorType[/**\n\t * PeerJS is being used securely, but the cloud server does not support SSL. Use a custom PeerServer.\n\t */ \"SslUnavailable\"] = \"ssl-unavailable\";\n    PeerErrorType[/**\n\t * Unable to reach the server.\n\t */ \"ServerError\"] = \"server-error\";\n    PeerErrorType[/**\n\t * An error from the underlying socket.\n\t */ \"SocketError\"] = \"socket-error\";\n    PeerErrorType[/**\n\t * The underlying socket closed unexpectedly.\n\t */ \"SocketClosed\"] = \"socket-closed\";\n    PeerErrorType[/**\n\t * The ID passed into the Peer constructor is already taken.\n\t *\n\t * :::caution\n\t * This error is not fatal if your peer has open peer-to-peer connections.\n\t * This can happen if you attempt to {@apilink Peer.reconnect} a peer that has been disconnected from the server,\n\t * but its old ID has now been taken.\n\t * :::\n\t */ \"UnavailableID\"] = \"unavailable-id\";\n    PeerErrorType[/**\n\t * Native WebRTC errors.\n\t */ \"WebRTC\"] = \"webrtc\";\n})($e07633d19f7426e9$export$9547aaa2e39030ff || ($e07633d19f7426e9$export$9547aaa2e39030ff = {}));\nvar $e07633d19f7426e9$export$7974935686149686;\n(function(BaseConnectionErrorType) {\n    BaseConnectionErrorType[\"NegotiationFailed\"] = \"negotiation-failed\";\n    BaseConnectionErrorType[\"ConnectionClosed\"] = \"connection-closed\";\n})($e07633d19f7426e9$export$7974935686149686 || ($e07633d19f7426e9$export$7974935686149686 = {}));\nvar $e07633d19f7426e9$export$49ae800c114df41d;\n(function(DataConnectionErrorType) {\n    DataConnectionErrorType[\"NotOpenYet\"] = \"not-open-yet\";\n    DataConnectionErrorType[\"MessageToBig\"] = \"message-too-big\";\n})($e07633d19f7426e9$export$49ae800c114df41d || ($e07633d19f7426e9$export$49ae800c114df41d = {}));\nvar $e07633d19f7426e9$export$89f507cf986a947;\n(function(SerializationType) {\n    SerializationType[\"Binary\"] = \"binary\";\n    SerializationType[\"BinaryUTF8\"] = \"binary-utf8\";\n    SerializationType[\"JSON\"] = \"json\";\n    SerializationType[\"None\"] = \"raw\";\n})($e07633d19f7426e9$export$89f507cf986a947 || ($e07633d19f7426e9$export$89f507cf986a947 = {}));\nvar $e07633d19f7426e9$export$3b5c4a4b6354f023;\n(function(SocketEventType) {\n    SocketEventType[\"Message\"] = \"message\";\n    SocketEventType[\"Disconnected\"] = \"disconnected\";\n    SocketEventType[\"Error\"] = \"error\";\n    SocketEventType[\"Close\"] = \"close\";\n})($e07633d19f7426e9$export$3b5c4a4b6354f023 || ($e07633d19f7426e9$export$3b5c4a4b6354f023 = {}));\nvar $e07633d19f7426e9$export$adb4a1754da6f10d;\n(function(ServerMessageType) {\n    ServerMessageType[\"Heartbeat\"] = \"HEARTBEAT\";\n    ServerMessageType[\"Candidate\"] = \"CANDIDATE\";\n    ServerMessageType[\"Offer\"] = \"OFFER\";\n    ServerMessageType[\"Answer\"] = \"ANSWER\";\n    ServerMessageType[\"Open\"] = \"OPEN\";\n    ServerMessageType[\"Error\"] = \"ERROR\";\n    ServerMessageType[\"IdTaken\"] = \"ID-TAKEN\";\n    ServerMessageType[\"InvalidKey\"] = \"INVALID-KEY\";\n    ServerMessageType[\"Leave\"] = \"LEAVE\";\n    ServerMessageType[\"Expire\"] = \"EXPIRE\";\n})($e07633d19f7426e9$export$adb4a1754da6f10d || ($e07633d19f7426e9$export$adb4a1754da6f10d = {}));\n\n\nclass $ee2f7acfd22ad8cb$export$89e6bb5ad64bf4a {\n    constructor(connection){\n        this.connection = connection;\n    }\n    /** Returns a PeerConnection object set up correctly (for data, media). */ startConnection(options) {\n        const peerConnection = this._startPeerConnection();\n        // Set the connection's PC.\n        this.connection.peerConnection = peerConnection;\n        if (this.connection.type === (0, $e07633d19f7426e9$export$3157d57b4135e3bc).Media && options._stream) this._addTracksToConnection(options._stream, peerConnection);\n        // What do we need to do now?\n        if (options.originator) {\n            const dataConnection = this.connection;\n            const config = {\n                ordered: !!options.reliable\n            };\n            const dataChannel = peerConnection.createDataChannel(dataConnection.label, config);\n            dataConnection._initializeDataChannel(dataChannel);\n            this._makeOffer();\n        } else this.handleSDP(\"OFFER\", options.sdp);\n    }\n    /** Start a PC. */ _startPeerConnection() {\n        (0, $55e90223fe532944$export$2e2bcd8739ae039).log(\"Creating RTCPeerConnection.\");\n        const peerConnection = new RTCPeerConnection(this.connection.provider.options.config);\n        this._setupListeners(peerConnection);\n        return peerConnection;\n    }\n    /** Set up various WebRTC listeners. */ _setupListeners(peerConnection) {\n        const peerId = this.connection.peer;\n        const connectionId = this.connection.connectionId;\n        const connectionType = this.connection.type;\n        const provider = this.connection.provider;\n        // ICE CANDIDATES.\n        (0, $55e90223fe532944$export$2e2bcd8739ae039).log(\"Listening for ICE candidates.\");\n        peerConnection.onicecandidate = (evt)=>{\n            if (!evt.candidate || !evt.candidate.candidate) return;\n            (0, $55e90223fe532944$export$2e2bcd8739ae039).log(`Received ICE candidates for ${peerId}:`, evt.candidate);\n            provider.socket.send({\n                type: (0, $e07633d19f7426e9$export$adb4a1754da6f10d).Candidate,\n                payload: {\n                    candidate: evt.candidate,\n                    type: connectionType,\n                    connectionId: connectionId\n                },\n                dst: peerId\n            });\n        };\n        peerConnection.oniceconnectionstatechange = ()=>{\n            switch(peerConnection.iceConnectionState){\n                case \"failed\":\n                    (0, $55e90223fe532944$export$2e2bcd8739ae039).log(\"iceConnectionState is failed, closing connections to \" + peerId);\n                    this.connection.emitError((0, $e07633d19f7426e9$export$7974935686149686).NegotiationFailed, \"Negotiation of connection to \" + peerId + \" failed.\");\n                    this.connection.close();\n                    break;\n                case \"closed\":\n                    (0, $55e90223fe532944$export$2e2bcd8739ae039).log(\"iceConnectionState is closed, closing connections to \" + peerId);\n                    this.connection.emitError((0, $e07633d19f7426e9$export$7974935686149686).ConnectionClosed, \"Connection to \" + peerId + \" closed.\");\n                    this.connection.close();\n                    break;\n                case \"disconnected\":\n                    (0, $55e90223fe532944$export$2e2bcd8739ae039).log(\"iceConnectionState changed to disconnected on the connection with \" + peerId);\n                    break;\n                case \"completed\":\n                    peerConnection.onicecandidate = ()=>{};\n                    break;\n            }\n            this.connection.emit(\"iceStateChanged\", peerConnection.iceConnectionState);\n        };\n        // DATACONNECTION.\n        (0, $55e90223fe532944$export$2e2bcd8739ae039).log(\"Listening for data channel\");\n        // Fired between offer and answer, so options should already be saved\n        // in the options hash.\n        peerConnection.ondatachannel = (evt)=>{\n            (0, $55e90223fe532944$export$2e2bcd8739ae039).log(\"Received data channel\");\n            const dataChannel = evt.channel;\n            const connection = provider.getConnection(peerId, connectionId);\n            connection._initializeDataChannel(dataChannel);\n        };\n        // MEDIACONNECTION.\n        (0, $55e90223fe532944$export$2e2bcd8739ae039).log(\"Listening for remote stream\");\n        peerConnection.ontrack = (evt)=>{\n            (0, $55e90223fe532944$export$2e2bcd8739ae039).log(\"Received remote stream\");\n            const stream = evt.streams[0];\n            const connection = provider.getConnection(peerId, connectionId);\n            if (connection.type === (0, $e07633d19f7426e9$export$3157d57b4135e3bc).Media) {\n                const mediaConnection = connection;\n                this._addStreamToMediaConnection(stream, mediaConnection);\n            }\n        };\n    }\n    cleanup() {\n        (0, $55e90223fe532944$export$2e2bcd8739ae039).log(\"Cleaning up PeerConnection to \" + this.connection.peer);\n        const peerConnection = this.connection.peerConnection;\n        if (!peerConnection) return;\n        this.connection.peerConnection = null;\n        //unsubscribe from all PeerConnection's events\n        peerConnection.onicecandidate = peerConnection.oniceconnectionstatechange = peerConnection.ondatachannel = peerConnection.ontrack = ()=>{};\n        const peerConnectionNotClosed = peerConnection.signalingState !== \"closed\";\n        let dataChannelNotClosed = false;\n        const dataChannel = this.connection.dataChannel;\n        if (dataChannel) dataChannelNotClosed = !!dataChannel.readyState && dataChannel.readyState !== \"closed\";\n        if (peerConnectionNotClosed || dataChannelNotClosed) peerConnection.close();\n    }\n    async _makeOffer() {\n        const peerConnection = this.connection.peerConnection;\n        const provider = this.connection.provider;\n        try {\n            const offer = await peerConnection.createOffer(this.connection.options.constraints);\n            (0, $55e90223fe532944$export$2e2bcd8739ae039).log(\"Created offer.\");\n            if (this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform === \"function\") offer.sdp = this.connection.options.sdpTransform(offer.sdp) || offer.sdp;\n            try {\n                await peerConnection.setLocalDescription(offer);\n                (0, $55e90223fe532944$export$2e2bcd8739ae039).log(\"Set localDescription:\", offer, `for:${this.connection.peer}`);\n                let payload = {\n                    sdp: offer,\n                    type: this.connection.type,\n                    connectionId: this.connection.connectionId,\n                    metadata: this.connection.metadata\n                };\n                if (this.connection.type === (0, $e07633d19f7426e9$export$3157d57b4135e3bc).Data) {\n                    const dataConnection = this.connection;\n                    payload = {\n                        ...payload,\n                        label: dataConnection.label,\n                        reliable: dataConnection.reliable,\n                        serialization: dataConnection.serialization\n                    };\n                }\n                provider.socket.send({\n                    type: (0, $e07633d19f7426e9$export$adb4a1754da6f10d).Offer,\n                    payload: payload,\n                    dst: this.connection.peer\n                });\n            } catch (err) {\n                // TODO: investigate why _makeOffer is being called from the answer\n                if (err != \"OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer\") {\n                    provider.emitError((0, $e07633d19f7426e9$export$9547aaa2e39030ff).WebRTC, err);\n                    (0, $55e90223fe532944$export$2e2bcd8739ae039).log(\"Failed to setLocalDescription, \", err);\n                }\n            }\n        } catch (err_1) {\n            provider.emitError((0, $e07633d19f7426e9$export$9547aaa2e39030ff).WebRTC, err_1);\n            (0, $55e90223fe532944$export$2e2bcd8739ae039).log(\"Failed to createOffer, \", err_1);\n        }\n    }\n    async _makeAnswer() {\n        const peerConnection = this.connection.peerConnection;\n        const provider = this.connection.provider;\n        try {\n            const answer = await peerConnection.createAnswer();\n            (0, $55e90223fe532944$export$2e2bcd8739ae039).log(\"Created answer.\");\n            if (this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform === \"function\") answer.sdp = this.connection.options.sdpTransform(answer.sdp) || answer.sdp;\n            try {\n                await peerConnection.setLocalDescription(answer);\n                (0, $55e90223fe532944$export$2e2bcd8739ae039).log(`Set localDescription:`, answer, `for:${this.connection.peer}`);\n                provider.socket.send({\n                    type: (0, $e07633d19f7426e9$export$adb4a1754da6f10d).Answer,\n                    payload: {\n                        sdp: answer,\n                        type: this.connection.type,\n                        connectionId: this.connection.connectionId\n                    },\n                    dst: this.connection.peer\n                });\n            } catch (err) {\n                provider.emitError((0, $e07633d19f7426e9$export$9547aaa2e39030ff).WebRTC, err);\n                (0, $55e90223fe532944$export$2e2bcd8739ae039).log(\"Failed to setLocalDescription, \", err);\n            }\n        } catch (err_1) {\n            provider.emitError((0, $e07633d19f7426e9$export$9547aaa2e39030ff).WebRTC, err_1);\n            (0, $55e90223fe532944$export$2e2bcd8739ae039).log(\"Failed to create answer, \", err_1);\n        }\n    }\n    /** Handle an SDP. */ async handleSDP(type, sdp) {\n        sdp = new RTCSessionDescription(sdp);\n        const peerConnection = this.connection.peerConnection;\n        const provider = this.connection.provider;\n        (0, $55e90223fe532944$export$2e2bcd8739ae039).log(\"Setting remote description\", sdp);\n        const self = this;\n        try {\n            await peerConnection.setRemoteDescription(sdp);\n            (0, $55e90223fe532944$export$2e2bcd8739ae039).log(`Set remoteDescription:${type} for:${this.connection.peer}`);\n            if (type === \"OFFER\") await self._makeAnswer();\n        } catch (err) {\n            provider.emitError((0, $e07633d19f7426e9$export$9547aaa2e39030ff).WebRTC, err);\n            (0, $55e90223fe532944$export$2e2bcd8739ae039).log(\"Failed to setRemoteDescription, \", err);\n        }\n    }\n    /** Handle a candidate. */ async handleCandidate(ice) {\n        (0, $55e90223fe532944$export$2e2bcd8739ae039).log(`handleCandidate:`, ice);\n        try {\n            await this.connection.peerConnection.addIceCandidate(ice);\n            (0, $55e90223fe532944$export$2e2bcd8739ae039).log(`Added ICE candidate for:${this.connection.peer}`);\n        } catch (err) {\n            this.connection.provider.emitError((0, $e07633d19f7426e9$export$9547aaa2e39030ff).WebRTC, err);\n            (0, $55e90223fe532944$export$2e2bcd8739ae039).log(\"Failed to handleCandidate, \", err);\n        }\n    }\n    _addTracksToConnection(stream, peerConnection) {\n        (0, $55e90223fe532944$export$2e2bcd8739ae039).log(`add tracks from stream ${stream.id} to peer connection`);\n        if (!peerConnection.addTrack) return (0, $55e90223fe532944$export$2e2bcd8739ae039).error(`Your browser does't support RTCPeerConnection#addTrack. Ignored.`);\n        stream.getTracks().forEach((track)=>{\n            peerConnection.addTrack(track, stream);\n        });\n    }\n    _addStreamToMediaConnection(stream, mediaConnection) {\n        (0, $55e90223fe532944$export$2e2bcd8739ae039).log(`add stream ${stream.id} to media connection ${mediaConnection.connectionId}`);\n        mediaConnection.addStream(stream);\n    }\n}\n\n\n\nvar $1961087dd546fd56$exports = {};\n\"use strict\";\nvar $1961087dd546fd56$var$has = Object.prototype.hasOwnProperty, $1961087dd546fd56$var$prefix = \"~\";\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */ function $1961087dd546fd56$var$Events() {}\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n    $1961087dd546fd56$var$Events.prototype = Object.create(null);\n    //\n    // This hack is needed because the `__proto__` property is still inherited in\n    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n    //\n    if (!new $1961087dd546fd56$var$Events().__proto__) $1961087dd546fd56$var$prefix = false;\n}\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */ function $1961087dd546fd56$var$EE(fn, context, once) {\n    this.fn = fn;\n    this.context = context;\n    this.once = once || false;\n}\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */ function $1961087dd546fd56$var$addListener(emitter, event, fn, context, once) {\n    if (typeof fn !== \"function\") throw new TypeError(\"The listener must be a function\");\n    var listener = new $1961087dd546fd56$var$EE(fn, context || emitter, once), evt = $1961087dd546fd56$var$prefix ? $1961087dd546fd56$var$prefix + event : event;\n    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n    else emitter._events[evt] = [\n        emitter._events[evt],\n        listener\n    ];\n    return emitter;\n}\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */ function $1961087dd546fd56$var$clearEvent(emitter, evt) {\n    if (--emitter._eventsCount === 0) emitter._events = new $1961087dd546fd56$var$Events();\n    else delete emitter._events[evt];\n}\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */ function $1961087dd546fd56$var$EventEmitter() {\n    this._events = new $1961087dd546fd56$var$Events();\n    this._eventsCount = 0;\n}\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */ $1961087dd546fd56$var$EventEmitter.prototype.eventNames = function eventNames() {\n    var names = [], events, name;\n    if (this._eventsCount === 0) return names;\n    for(name in events = this._events)if ($1961087dd546fd56$var$has.call(events, name)) names.push($1961087dd546fd56$var$prefix ? name.slice(1) : name);\n    if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events));\n    return names;\n};\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */ $1961087dd546fd56$var$EventEmitter.prototype.listeners = function listeners(event) {\n    var evt = $1961087dd546fd56$var$prefix ? $1961087dd546fd56$var$prefix + event : event, handlers = this._events[evt];\n    if (!handlers) return [];\n    if (handlers.fn) return [\n        handlers.fn\n    ];\n    for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++)ee[i] = handlers[i].fn;\n    return ee;\n};\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */ $1961087dd546fd56$var$EventEmitter.prototype.listenerCount = function listenerCount(event) {\n    var evt = $1961087dd546fd56$var$prefix ? $1961087dd546fd56$var$prefix + event : event, listeners = this._events[evt];\n    if (!listeners) return 0;\n    if (listeners.fn) return 1;\n    return listeners.length;\n};\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */ $1961087dd546fd56$var$EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n    var evt = $1961087dd546fd56$var$prefix ? $1961087dd546fd56$var$prefix + event : event;\n    if (!this._events[evt]) return false;\n    var listeners = this._events[evt], len = arguments.length, args, i;\n    if (listeners.fn) {\n        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n        switch(len){\n            case 1:\n                return listeners.fn.call(listeners.context), true;\n            case 2:\n                return listeners.fn.call(listeners.context, a1), true;\n            case 3:\n                return listeners.fn.call(listeners.context, a1, a2), true;\n            case 4:\n                return listeners.fn.call(listeners.context, a1, a2, a3), true;\n            case 5:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n            case 6:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n        }\n        for(i = 1, args = new Array(len - 1); i < len; i++)args[i - 1] = arguments[i];\n        listeners.fn.apply(listeners.context, args);\n    } else {\n        var length = listeners.length, j;\n        for(i = 0; i < length; i++){\n            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n            switch(len){\n                case 1:\n                    listeners[i].fn.call(listeners[i].context);\n                    break;\n                case 2:\n                    listeners[i].fn.call(listeners[i].context, a1);\n                    break;\n                case 3:\n                    listeners[i].fn.call(listeners[i].context, a1, a2);\n                    break;\n                case 4:\n                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n                    break;\n                default:\n                    if (!args) for(j = 1, args = new Array(len - 1); j < len; j++)args[j - 1] = arguments[j];\n                    listeners[i].fn.apply(listeners[i].context, args);\n            }\n        }\n    }\n    return true;\n};\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */ $1961087dd546fd56$var$EventEmitter.prototype.on = function on(event, fn, context) {\n    return $1961087dd546fd56$var$addListener(this, event, fn, context, false);\n};\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */ $1961087dd546fd56$var$EventEmitter.prototype.once = function once(event, fn, context) {\n    return $1961087dd546fd56$var$addListener(this, event, fn, context, true);\n};\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */ $1961087dd546fd56$var$EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n    var evt = $1961087dd546fd56$var$prefix ? $1961087dd546fd56$var$prefix + event : event;\n    if (!this._events[evt]) return this;\n    if (!fn) {\n        $1961087dd546fd56$var$clearEvent(this, evt);\n        return this;\n    }\n    var listeners = this._events[evt];\n    if (listeners.fn) {\n        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) $1961087dd546fd56$var$clearEvent(this, evt);\n    } else {\n        for(var i = 0, events = [], length = listeners.length; i < length; i++)if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) events.push(listeners[i]);\n        //\n        // Reset the array, or remove it completely if we have no more listeners.\n        //\n        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n        else $1961087dd546fd56$var$clearEvent(this, evt);\n    }\n    return this;\n};\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */ $1961087dd546fd56$var$EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n    var evt;\n    if (event) {\n        evt = $1961087dd546fd56$var$prefix ? $1961087dd546fd56$var$prefix + event : event;\n        if (this._events[evt]) $1961087dd546fd56$var$clearEvent(this, evt);\n    } else {\n        this._events = new $1961087dd546fd56$var$Events();\n        this._eventsCount = 0;\n    }\n    return this;\n};\n//\n// Alias methods names because people roll like that.\n//\n$1961087dd546fd56$var$EventEmitter.prototype.off = $1961087dd546fd56$var$EventEmitter.prototype.removeListener;\n$1961087dd546fd56$var$EventEmitter.prototype.addListener = $1961087dd546fd56$var$EventEmitter.prototype.on;\n//\n// Expose the prefix.\n//\n$1961087dd546fd56$var$EventEmitter.prefixed = $1961087dd546fd56$var$prefix;\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\n$1961087dd546fd56$var$EventEmitter.EventEmitter = $1961087dd546fd56$var$EventEmitter;\n$1961087dd546fd56$exports = $1961087dd546fd56$var$EventEmitter;\n\n\n\nclass $428dbabfb6f47b54$export$6a678e589c8a4542 extends (0, $1961087dd546fd56$exports.EventEmitter) {\n    /**\n\t * Emits a typed error message.\n\t *\n\t * @internal\n\t */ emitError(type, err) {\n        (0, $55e90223fe532944$export$2e2bcd8739ae039).error(\"Error:\", err);\n        // @ts-ignore\n        this.emit(\"error\", new $428dbabfb6f47b54$export$98871882f492de82(`${type}`, err));\n    }\n}\nclass $428dbabfb6f47b54$export$98871882f492de82 extends Error {\n    /**\n\t * @internal\n\t */ constructor(type, err){\n        if (typeof err === \"string\") super(err);\n        else {\n            super();\n            Object.assign(this, err);\n        }\n        this.type = type;\n    }\n}\n\n\nclass $76eedc1a03766751$export$23a2a68283c24d80 extends (0, $428dbabfb6f47b54$export$6a678e589c8a4542) {\n    /**\n\t * Whether the media connection is active (e.g. your call has been answered).\n\t * You can check this if you want to set a maximum wait time for a one-sided call.\n\t */ get open() {\n        return this._open;\n    }\n    constructor(peer, provider, options){\n        super();\n        this.peer = peer;\n        this.provider = provider;\n        this.options = options;\n        this._open = false;\n        this.metadata = options.metadata;\n    }\n}\n\n\nconst $eb916fa843978df9$export$4e61f672936bec77 = ()=>Math.random().toString(36).slice(2);\n\n\nclass $f7363ab6888d1e18$export$d365f7ad9d7df9c9 extends (0, $76eedc1a03766751$export$23a2a68283c24d80) {\n    static #_ = (()=>{\n        this.ID_PREFIX = \"dc_\";\n    })();\n    static #_1 = (()=>{\n        this.MAX_BUFFERED_AMOUNT = 8388608;\n    })();\n    get type() {\n        return (0, $e07633d19f7426e9$export$3157d57b4135e3bc).Data;\n    }\n    constructor(peerId, provider, options){\n        super(peerId, provider, options);\n        this.connectionId = this.options.connectionId || $f7363ab6888d1e18$export$d365f7ad9d7df9c9.ID_PREFIX + (0, $eb916fa843978df9$export$4e61f672936bec77)();\n        this.label = this.options.label || this.connectionId;\n        this.reliable = !!this.options.reliable;\n        this._negotiator = new (0, $ee2f7acfd22ad8cb$export$89e6bb5ad64bf4a)(this);\n        this._negotiator.startConnection(this.options._payload || {\n            originator: true,\n            reliable: this.reliable\n        });\n    }\n    /** Called by the Negotiator when the DataChannel is ready. */ _initializeDataChannel(dc) {\n        this.dataChannel = dc;\n        this.dataChannel.onopen = ()=>{\n            (0, $55e90223fe532944$export$2e2bcd8739ae039).log(`DC#${this.connectionId} dc connection success`);\n            this._open = true;\n            this.emit(\"open\");\n        };\n        this.dataChannel.onmessage = (e)=>{\n            (0, $55e90223fe532944$export$2e2bcd8739ae039).log(`DC#${this.connectionId} dc onmessage:`, e.data);\n        // this._handleDataMessage(e);\n        };\n        this.dataChannel.onclose = ()=>{\n            (0, $55e90223fe532944$export$2e2bcd8739ae039).log(`DC#${this.connectionId} dc closed for:`, this.peer);\n            this.close();\n        };\n    }\n    /**\n\t * Exposed functionality for users.\n\t */ /** Allows user to close connection. */ close(options) {\n        if (options?.flush) {\n            this.send({\n                __peerData: {\n                    type: \"close\"\n                }\n            });\n            return;\n        }\n        if (this._negotiator) {\n            this._negotiator.cleanup();\n            this._negotiator = null;\n        }\n        if (this.provider) {\n            this.provider._removeConnection(this);\n            this.provider = null;\n        }\n        if (this.dataChannel) {\n            this.dataChannel.onopen = null;\n            this.dataChannel.onmessage = null;\n            this.dataChannel.onclose = null;\n            this.dataChannel = null;\n        }\n        if (!this.open) return;\n        this._open = false;\n        super.emit(\"close\");\n    }\n    /** Allows user to send data. */ send(data, chunked = false) {\n        if (!this.open) {\n            this.emitError((0, $e07633d19f7426e9$export$49ae800c114df41d).NotOpenYet, \"Connection is not open. You should listen for the `open` event before sending messages.\");\n            return;\n        }\n        return this._send(data, chunked);\n    }\n    async handleMessage(message) {\n        const payload = message.payload;\n        switch(message.type){\n            case (0, $e07633d19f7426e9$export$adb4a1754da6f10d).Answer:\n                await this._negotiator.handleSDP(message.type, payload.sdp);\n                break;\n            case (0, $e07633d19f7426e9$export$adb4a1754da6f10d).Candidate:\n                await this._negotiator.handleCandidate(payload.candidate);\n                break;\n            default:\n                (0, $55e90223fe532944$export$2e2bcd8739ae039).warn(\"Unrecognized message type:\", message.type, \"from peer:\", this.peer);\n                break;\n        }\n    }\n}\n\n\nclass $b68ef8ad985e69ce$export$72aa44612e2200cd extends (0, $f7363ab6888d1e18$export$d365f7ad9d7df9c9) {\n    constructor(peerId, provider, options){\n        super(peerId, provider, {\n            ...options,\n            reliable: true\n        });\n        this._CHUNK_SIZE = 32768;\n        this._splitStream = new TransformStream({\n            transform: (chunk, controller)=>{\n                for(let split = 0; split < chunk.length; split += this._CHUNK_SIZE)controller.enqueue(chunk.subarray(split, split + this._CHUNK_SIZE));\n            }\n        });\n        this._rawSendStream = new WritableStream({\n            write: async (chunk, controller)=>{\n                const openEvent = new Promise((resolve)=>this.dataChannel.addEventListener(\"bufferedamountlow\", resolve, {\n                        once: true\n                    }));\n                // if we can send the chunk now, send it\n                // if not, we wait until at least half of the sending buffer is free again\n                await (this.dataChannel.bufferedAmount <= (0, $f7363ab6888d1e18$export$d365f7ad9d7df9c9).MAX_BUFFERED_AMOUNT - chunk.byteLength || openEvent);\n                // TODO: what can go wrong here?\n                try {\n                    this.dataChannel.send(chunk);\n                } catch (e) {\n                    (0, $55e90223fe532944$export$2e2bcd8739ae039).error(`DC#:${this.connectionId} Error when sending:`, e);\n                    controller.error(e);\n                    this.close();\n                }\n            }\n        });\n        this.writer = this._splitStream.writable.getWriter();\n        this._rawReadStream = new ReadableStream({\n            start: (controller)=>{\n                this.once(\"open\", ()=>{\n                    this.dataChannel.addEventListener(\"message\", (e)=>{\n                        controller.enqueue(e.data);\n                    });\n                });\n            }\n        });\n        this._splitStream.readable.pipeTo(this._rawSendStream);\n    }\n    _initializeDataChannel(dc) {\n        super._initializeDataChannel(dc);\n        this.dataChannel.binaryType = \"arraybuffer\";\n        this.dataChannel.bufferedAmountLowThreshold = (0, $f7363ab6888d1e18$export$d365f7ad9d7df9c9).MAX_BUFFERED_AMOUNT / 2;\n    }\n}\n\n\nclass $115c516f1c55edeb$export$80f5de1a66c4d624 extends (0, $b68ef8ad985e69ce$export$72aa44612e2200cd) {\n    constructor(peerId, provider, options){\n        super(peerId, provider, options);\n        this.serialization = \"MsgPack\";\n        this._encoder = new (0, $c94702bf03c532e7$export$a50aceb0e02a00aa)();\n        (async ()=>{\n            for await (const msg of (0, $5dbeafcd6e23d52f$exports.decodeMultiStream)(this._rawReadStream)){\n                // @ts-ignore\n                if (msg.__peerData?.type === \"close\") {\n                    this.close();\n                    return;\n                }\n                this.emit(\"data\", msg);\n            }\n        })();\n    }\n    _send(data) {\n        return this.writer.write(this._encoder.encode(data));\n    }\n}\n\n\nexport {$115c516f1c55edeb$export$80f5de1a66c4d624 as MsgPack};\n//# sourceMappingURL=serializer.msgpack.mjs.map\n","import { decodeMultiStream, Encoder } from \"@msgpack/msgpack\";\nimport { StreamConnection } from \"./StreamConnection.js\";\nimport type { Peer } from \"../../peer.js\";\n\nexport class MsgPack extends StreamConnection {\n\treadonly serialization = \"MsgPack\";\n\tprivate _encoder = new Encoder();\n\n\tconstructor(peerId: string, provider: Peer, options: any) {\n\t\tsuper(peerId, provider, options);\n\n\t\t(async () => {\n\t\t\tfor await (const msg of decodeMultiStream(this._rawReadStream)) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tif (msg.__peerData?.type === \"close\") {\n\t\t\t\t\tthis.close();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.emit(\"data\", msg);\n\t\t\t}\n\t\t})();\n\t}\n\n\tprotected override _send(data) {\n\t\treturn this.writer.write(this._encoder.encode(data));\n\t}\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { Decoder } from \"./Decoder.mjs\";\nimport { ensureAsyncIterable } from \"./utils/stream.mjs\";\nimport { defaultDecodeOptions } from \"./decode.mjs\";\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeAsync(streamLike, options) {\n    if (options === void 0) { options = defaultDecodeOptions; }\n    return __awaiter(this, void 0, void 0, function () {\n        var stream, decoder;\n        return __generator(this, function (_a) {\n            stream = ensureAsyncIterable(streamLike);\n            decoder = new Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return [2 /*return*/, decoder.decodeAsync(stream)];\n        });\n    });\n}\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeArrayStream(streamLike, options) {\n    if (options === void 0) { options = defaultDecodeOptions; }\n    var stream = ensureAsyncIterable(streamLike);\n    var decoder = new Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decodeArrayStream(stream);\n}\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeMultiStream(streamLike, options) {\n    if (options === void 0) { options = defaultDecodeOptions; }\n    var stream = ensureAsyncIterable(streamLike);\n    var decoder = new Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decodeStream(stream);\n}\n/**\n * @deprecated Use {@link decodeMultiStream()} instead.\n */\nexport function decodeStream(streamLike, options) {\n    if (options === void 0) { options = defaultDecodeOptions; }\n    return decodeMultiStream(streamLike, options);\n}\n//# sourceMappingURL=decodeAsync.mjs.map","import { Decoder } from \"./Decoder\";\nimport { ensureAsyncIterable } from \"./utils/stream\";\nimport { defaultDecodeOptions } from \"./decode\";\nimport type { ReadableStreamLike } from \"./utils/stream\";\nimport type { DecodeOptions } from \"./decode\";\nimport type { SplitUndefined } from \"./context\";\n\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\n export async function decodeAsync<ContextType>(\n  streamLike: ReadableStreamLike<ArrayLike<number> | BufferSource>,\n  options: DecodeOptions<SplitUndefined<ContextType>> = defaultDecodeOptions as any,\n): Promise<unknown> {\n  const stream = ensureAsyncIterable(streamLike);\n\n  const decoder = new Decoder(\n    options.extensionCodec,\n    (options as typeof options & { context: any }).context,\n    options.maxStrLength,\n    options.maxBinLength,\n    options.maxArrayLength,\n    options.maxMapLength,\n    options.maxExtLength,\n  );\n  return decoder.decodeAsync(stream);\n}\n\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\n export function decodeArrayStream<ContextType>(\n  streamLike: ReadableStreamLike<ArrayLike<number> | BufferSource>,\n  options: DecodeOptions<SplitUndefined<ContextType>> = defaultDecodeOptions as any,\n): AsyncGenerator<unknown, void, unknown> {\n  const stream = ensureAsyncIterable(streamLike);\n\n  const decoder = new Decoder(\n    options.extensionCodec,\n    (options as typeof options & { context: any }).context,\n    options.maxStrLength,\n    options.maxBinLength,\n    options.maxArrayLength,\n    options.maxMapLength,\n    options.maxExtLength,\n  );\n\n  return decoder.decodeArrayStream(stream);\n}\n\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeMultiStream<ContextType>(\n  streamLike: ReadableStreamLike<ArrayLike<number> | BufferSource>,\n  options: DecodeOptions<SplitUndefined<ContextType>> = defaultDecodeOptions as any,\n): AsyncGenerator<unknown, void, unknown> {\n  const stream = ensureAsyncIterable(streamLike);\n\n  const decoder = new Decoder(\n    options.extensionCodec,\n    (options as typeof options & { context: any }).context,\n    options.maxStrLength,\n    options.maxBinLength,\n    options.maxArrayLength,\n    options.maxMapLength,\n    options.maxExtLength,\n  );\n\n  return decoder.decodeStream(stream);\n}\n\n/**\n * @deprecated Use {@link decodeMultiStream()} instead.\n */\nexport function decodeStream<ContextType>(\n  streamLike: ReadableStreamLike<ArrayLike<number> | BufferSource>,\n  options: DecodeOptions<SplitUndefined<ContextType>> = defaultDecodeOptions as any,\n): AsyncGenerator<unknown, void, unknown> {\n  return decodeMultiStream(streamLike, options);\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nimport { prettyByte } from \"./utils/prettyByte.mjs\";\nimport { ExtensionCodec } from \"./ExtensionCodec.mjs\";\nimport { getInt64, getUint64, UINT32_MAX } from \"./utils/int.mjs\";\nimport { utf8DecodeJs, TEXT_DECODER_THRESHOLD, utf8DecodeTD } from \"./utils/utf8.mjs\";\nimport { createDataView, ensureUint8Array } from \"./utils/typedArrays.mjs\";\nimport { CachedKeyDecoder } from \"./CachedKeyDecoder.mjs\";\nimport { DecodeError } from \"./DecodeError.mjs\";\nvar isValidMapKeyType = function (key) {\n    var keyType = typeof key;\n    return keyType === \"string\" || keyType === \"number\";\n};\nvar HEAD_BYTE_REQUIRED = -1;\nvar EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nvar EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n// IE11: Hack to support IE11.\n// IE11: Drop this hack and just use RangeError when IE11 is obsolete.\nexport var DataViewIndexOutOfBoundsError = (function () {\n    try {\n        // IE11: The spec says it should throw RangeError,\n        // IE11: but in IE11 it throws TypeError.\n        EMPTY_VIEW.getInt8(0);\n    }\n    catch (e) {\n        return e.constructor;\n    }\n    throw new Error(\"never reached\");\n})();\nvar MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\nvar sharedCachedKeyDecoder = new CachedKeyDecoder();\nvar Decoder = /** @class */ (function () {\n    function Decoder(extensionCodec, context, maxStrLength, maxBinLength, maxArrayLength, maxMapLength, maxExtLength, keyDecoder) {\n        if (extensionCodec === void 0) { extensionCodec = ExtensionCodec.defaultCodec; }\n        if (context === void 0) { context = undefined; }\n        if (maxStrLength === void 0) { maxStrLength = UINT32_MAX; }\n        if (maxBinLength === void 0) { maxBinLength = UINT32_MAX; }\n        if (maxArrayLength === void 0) { maxArrayLength = UINT32_MAX; }\n        if (maxMapLength === void 0) { maxMapLength = UINT32_MAX; }\n        if (maxExtLength === void 0) { maxExtLength = UINT32_MAX; }\n        if (keyDecoder === void 0) { keyDecoder = sharedCachedKeyDecoder; }\n        this.extensionCodec = extensionCodec;\n        this.context = context;\n        this.maxStrLength = maxStrLength;\n        this.maxBinLength = maxBinLength;\n        this.maxArrayLength = maxArrayLength;\n        this.maxMapLength = maxMapLength;\n        this.maxExtLength = maxExtLength;\n        this.keyDecoder = keyDecoder;\n        this.totalPos = 0;\n        this.pos = 0;\n        this.view = EMPTY_VIEW;\n        this.bytes = EMPTY_BYTES;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack = [];\n    }\n    Decoder.prototype.reinitializeState = function () {\n        this.totalPos = 0;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack.length = 0;\n        // view, bytes, and pos will be re-initialized in setBuffer()\n    };\n    Decoder.prototype.setBuffer = function (buffer) {\n        this.bytes = ensureUint8Array(buffer);\n        this.view = createDataView(this.bytes);\n        this.pos = 0;\n    };\n    Decoder.prototype.appendBuffer = function (buffer) {\n        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n            this.setBuffer(buffer);\n        }\n        else {\n            var remainingData = this.bytes.subarray(this.pos);\n            var newData = ensureUint8Array(buffer);\n            // concat remainingData + newData\n            var newBuffer = new Uint8Array(remainingData.length + newData.length);\n            newBuffer.set(remainingData);\n            newBuffer.set(newData, remainingData.length);\n            this.setBuffer(newBuffer);\n        }\n    };\n    Decoder.prototype.hasRemaining = function (size) {\n        return this.view.byteLength - this.pos >= size;\n    };\n    Decoder.prototype.createExtraByteError = function (posToShow) {\n        var _a = this, view = _a.view, pos = _a.pos;\n        return new RangeError(\"Extra \".concat(view.byteLength - pos, \" of \").concat(view.byteLength, \" byte(s) found at buffer[\").concat(posToShow, \"]\"));\n    };\n    /**\n     * @throws {@link DecodeError}\n     * @throws {@link RangeError}\n     */\n    Decoder.prototype.decode = function (buffer) {\n        this.reinitializeState();\n        this.setBuffer(buffer);\n        var object = this.doDecodeSync();\n        if (this.hasRemaining(1)) {\n            throw this.createExtraByteError(this.pos);\n        }\n        return object;\n    };\n    Decoder.prototype.decodeMulti = function (buffer) {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    this.reinitializeState();\n                    this.setBuffer(buffer);\n                    _a.label = 1;\n                case 1:\n                    if (!this.hasRemaining(1)) return [3 /*break*/, 3];\n                    return [4 /*yield*/, this.doDecodeSync()];\n                case 2:\n                    _a.sent();\n                    return [3 /*break*/, 1];\n                case 3: return [2 /*return*/];\n            }\n        });\n    };\n    Decoder.prototype.decodeAsync = function (stream) {\n        var stream_1, stream_1_1;\n        var e_1, _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var decoded, object, buffer, e_1_1, _b, headByte, pos, totalPos;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        decoded = false;\n                        _c.label = 1;\n                    case 1:\n                        _c.trys.push([1, 6, 7, 12]);\n                        stream_1 = __asyncValues(stream);\n                        _c.label = 2;\n                    case 2: return [4 /*yield*/, stream_1.next()];\n                    case 3:\n                        if (!(stream_1_1 = _c.sent(), !stream_1_1.done)) return [3 /*break*/, 5];\n                        buffer = stream_1_1.value;\n                        if (decoded) {\n                            throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        try {\n                            object = this.doDecodeSync();\n                            decoded = true;\n                        }\n                        catch (e) {\n                            if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n                                throw e; // rethrow\n                            }\n                            // fallthrough\n                        }\n                        this.totalPos += this.pos;\n                        _c.label = 4;\n                    case 4: return [3 /*break*/, 2];\n                    case 5: return [3 /*break*/, 12];\n                    case 6:\n                        e_1_1 = _c.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 12];\n                    case 7:\n                        _c.trys.push([7, , 10, 11]);\n                        if (!(stream_1_1 && !stream_1_1.done && (_a = stream_1.return))) return [3 /*break*/, 9];\n                        return [4 /*yield*/, _a.call(stream_1)];\n                    case 8:\n                        _c.sent();\n                        _c.label = 9;\n                    case 9: return [3 /*break*/, 11];\n                    case 10:\n                        if (e_1) throw e_1.error;\n                        return [7 /*endfinally*/];\n                    case 11: return [7 /*endfinally*/];\n                    case 12:\n                        if (decoded) {\n                            if (this.hasRemaining(1)) {\n                                throw this.createExtraByteError(this.totalPos);\n                            }\n                            return [2 /*return*/, object];\n                        }\n                        _b = this, headByte = _b.headByte, pos = _b.pos, totalPos = _b.totalPos;\n                        throw new RangeError(\"Insufficient data in parsing \".concat(prettyByte(headByte), \" at \").concat(totalPos, \" (\").concat(pos, \" in the current buffer)\"));\n                }\n            });\n        });\n    };\n    Decoder.prototype.decodeArrayStream = function (stream) {\n        return this.decodeMultiAsync(stream, true);\n    };\n    Decoder.prototype.decodeStream = function (stream) {\n        return this.decodeMultiAsync(stream, false);\n    };\n    Decoder.prototype.decodeMultiAsync = function (stream, isArray) {\n        return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {\n            var isArrayHeaderRequired, arrayItemsLeft, stream_2, stream_2_1, buffer, e_2, e_3_1;\n            var e_3, _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        isArrayHeaderRequired = isArray;\n                        arrayItemsLeft = -1;\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, 13, 14, 19]);\n                        stream_2 = __asyncValues(stream);\n                        _b.label = 2;\n                    case 2: return [4 /*yield*/, __await(stream_2.next())];\n                    case 3:\n                        if (!(stream_2_1 = _b.sent(), !stream_2_1.done)) return [3 /*break*/, 12];\n                        buffer = stream_2_1.value;\n                        if (isArray && arrayItemsLeft === 0) {\n                            throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        if (isArrayHeaderRequired) {\n                            arrayItemsLeft = this.readArraySize();\n                            isArrayHeaderRequired = false;\n                            this.complete();\n                        }\n                        _b.label = 4;\n                    case 4:\n                        _b.trys.push([4, 9, , 10]);\n                        _b.label = 5;\n                    case 5:\n                        if (!true) return [3 /*break*/, 8];\n                        return [4 /*yield*/, __await(this.doDecodeSync())];\n                    case 6: return [4 /*yield*/, _b.sent()];\n                    case 7:\n                        _b.sent();\n                        if (--arrayItemsLeft === 0) {\n                            return [3 /*break*/, 8];\n                        }\n                        return [3 /*break*/, 5];\n                    case 8: return [3 /*break*/, 10];\n                    case 9:\n                        e_2 = _b.sent();\n                        if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {\n                            throw e_2; // rethrow\n                        }\n                        return [3 /*break*/, 10];\n                    case 10:\n                        this.totalPos += this.pos;\n                        _b.label = 11;\n                    case 11: return [3 /*break*/, 2];\n                    case 12: return [3 /*break*/, 19];\n                    case 13:\n                        e_3_1 = _b.sent();\n                        e_3 = { error: e_3_1 };\n                        return [3 /*break*/, 19];\n                    case 14:\n                        _b.trys.push([14, , 17, 18]);\n                        if (!(stream_2_1 && !stream_2_1.done && (_a = stream_2.return))) return [3 /*break*/, 16];\n                        return [4 /*yield*/, __await(_a.call(stream_2))];\n                    case 15:\n                        _b.sent();\n                        _b.label = 16;\n                    case 16: return [3 /*break*/, 18];\n                    case 17:\n                        if (e_3) throw e_3.error;\n                        return [7 /*endfinally*/];\n                    case 18: return [7 /*endfinally*/];\n                    case 19: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Decoder.prototype.doDecodeSync = function () {\n        DECODE: while (true) {\n            var headByte = this.readHeadByte();\n            var object = void 0;\n            if (headByte >= 0xe0) {\n                // negative fixint (111x xxxx) 0xe0 - 0xff\n                object = headByte - 0x100;\n            }\n            else if (headByte < 0xc0) {\n                if (headByte < 0x80) {\n                    // positive fixint (0xxx xxxx) 0x00 - 0x7f\n                    object = headByte;\n                }\n                else if (headByte < 0x90) {\n                    // fixmap (1000 xxxx) 0x80 - 0x8f\n                    var size = headByte - 0x80;\n                    if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = {};\n                    }\n                }\n                else if (headByte < 0xa0) {\n                    // fixarray (1001 xxxx) 0x90 - 0x9f\n                    var size = headByte - 0x90;\n                    if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = [];\n                    }\n                }\n                else {\n                    // fixstr (101x xxxx) 0xa0 - 0xbf\n                    var byteLength = headByte - 0xa0;\n                    object = this.decodeUtf8String(byteLength, 0);\n                }\n            }\n            else if (headByte === 0xc0) {\n                // nil\n                object = null;\n            }\n            else if (headByte === 0xc2) {\n                // false\n                object = false;\n            }\n            else if (headByte === 0xc3) {\n                // true\n                object = true;\n            }\n            else if (headByte === 0xca) {\n                // float 32\n                object = this.readF32();\n            }\n            else if (headByte === 0xcb) {\n                // float 64\n                object = this.readF64();\n            }\n            else if (headByte === 0xcc) {\n                // uint 8\n                object = this.readU8();\n            }\n            else if (headByte === 0xcd) {\n                // uint 16\n                object = this.readU16();\n            }\n            else if (headByte === 0xce) {\n                // uint 32\n                object = this.readU32();\n            }\n            else if (headByte === 0xcf) {\n                // uint 64\n                object = this.readU64();\n            }\n            else if (headByte === 0xd0) {\n                // int 8\n                object = this.readI8();\n            }\n            else if (headByte === 0xd1) {\n                // int 16\n                object = this.readI16();\n            }\n            else if (headByte === 0xd2) {\n                // int 32\n                object = this.readI32();\n            }\n            else if (headByte === 0xd3) {\n                // int 64\n                object = this.readI64();\n            }\n            else if (headByte === 0xd9) {\n                // str 8\n                var byteLength = this.lookU8();\n                object = this.decodeUtf8String(byteLength, 1);\n            }\n            else if (headByte === 0xda) {\n                // str 16\n                var byteLength = this.lookU16();\n                object = this.decodeUtf8String(byteLength, 2);\n            }\n            else if (headByte === 0xdb) {\n                // str 32\n                var byteLength = this.lookU32();\n                object = this.decodeUtf8String(byteLength, 4);\n            }\n            else if (headByte === 0xdc) {\n                // array 16\n                var size = this.readU16();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xdd) {\n                // array 32\n                var size = this.readU32();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xde) {\n                // map 16\n                var size = this.readU16();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xdf) {\n                // map 32\n                var size = this.readU32();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xc4) {\n                // bin 8\n                var size = this.lookU8();\n                object = this.decodeBinary(size, 1);\n            }\n            else if (headByte === 0xc5) {\n                // bin 16\n                var size = this.lookU16();\n                object = this.decodeBinary(size, 2);\n            }\n            else if (headByte === 0xc6) {\n                // bin 32\n                var size = this.lookU32();\n                object = this.decodeBinary(size, 4);\n            }\n            else if (headByte === 0xd4) {\n                // fixext 1\n                object = this.decodeExtension(1, 0);\n            }\n            else if (headByte === 0xd5) {\n                // fixext 2\n                object = this.decodeExtension(2, 0);\n            }\n            else if (headByte === 0xd6) {\n                // fixext 4\n                object = this.decodeExtension(4, 0);\n            }\n            else if (headByte === 0xd7) {\n                // fixext 8\n                object = this.decodeExtension(8, 0);\n            }\n            else if (headByte === 0xd8) {\n                // fixext 16\n                object = this.decodeExtension(16, 0);\n            }\n            else if (headByte === 0xc7) {\n                // ext 8\n                var size = this.lookU8();\n                object = this.decodeExtension(size, 1);\n            }\n            else if (headByte === 0xc8) {\n                // ext 16\n                var size = this.lookU16();\n                object = this.decodeExtension(size, 2);\n            }\n            else if (headByte === 0xc9) {\n                // ext 32\n                var size = this.lookU32();\n                object = this.decodeExtension(size, 4);\n            }\n            else {\n                throw new DecodeError(\"Unrecognized type byte: \".concat(prettyByte(headByte)));\n            }\n            this.complete();\n            var stack = this.stack;\n            while (stack.length > 0) {\n                // arrays and maps\n                var state = stack[stack.length - 1];\n                if (state.type === 0 /* State.ARRAY */) {\n                    state.array[state.position] = object;\n                    state.position++;\n                    if (state.position === state.size) {\n                        stack.pop();\n                        object = state.array;\n                    }\n                    else {\n                        continue DECODE;\n                    }\n                }\n                else if (state.type === 1 /* State.MAP_KEY */) {\n                    if (!isValidMapKeyType(object)) {\n                        throw new DecodeError(\"The type of key must be string or number but \" + typeof object);\n                    }\n                    if (object === \"__proto__\") {\n                        throw new DecodeError(\"The key __proto__ is not allowed\");\n                    }\n                    state.key = object;\n                    state.type = 2 /* State.MAP_VALUE */;\n                    continue DECODE;\n                }\n                else {\n                    // it must be `state.type === State.MAP_VALUE` here\n                    state.map[state.key] = object;\n                    state.readCount++;\n                    if (state.readCount === state.size) {\n                        stack.pop();\n                        object = state.map;\n                    }\n                    else {\n                        state.key = null;\n                        state.type = 1 /* State.MAP_KEY */;\n                        continue DECODE;\n                    }\n                }\n            }\n            return object;\n        }\n    };\n    Decoder.prototype.readHeadByte = function () {\n        if (this.headByte === HEAD_BYTE_REQUIRED) {\n            this.headByte = this.readU8();\n            // console.log(\"headByte\", prettyByte(this.headByte));\n        }\n        return this.headByte;\n    };\n    Decoder.prototype.complete = function () {\n        this.headByte = HEAD_BYTE_REQUIRED;\n    };\n    Decoder.prototype.readArraySize = function () {\n        var headByte = this.readHeadByte();\n        switch (headByte) {\n            case 0xdc:\n                return this.readU16();\n            case 0xdd:\n                return this.readU32();\n            default: {\n                if (headByte < 0xa0) {\n                    return headByte - 0x90;\n                }\n                else {\n                    throw new DecodeError(\"Unrecognized array type byte: \".concat(prettyByte(headByte)));\n                }\n            }\n        }\n    };\n    Decoder.prototype.pushMapState = function (size) {\n        if (size > this.maxMapLength) {\n            throw new DecodeError(\"Max length exceeded: map length (\".concat(size, \") > maxMapLengthLength (\").concat(this.maxMapLength, \")\"));\n        }\n        this.stack.push({\n            type: 1 /* State.MAP_KEY */,\n            size: size,\n            key: null,\n            readCount: 0,\n            map: {},\n        });\n    };\n    Decoder.prototype.pushArrayState = function (size) {\n        if (size > this.maxArrayLength) {\n            throw new DecodeError(\"Max length exceeded: array length (\".concat(size, \") > maxArrayLength (\").concat(this.maxArrayLength, \")\"));\n        }\n        this.stack.push({\n            type: 0 /* State.ARRAY */,\n            size: size,\n            array: new Array(size),\n            position: 0,\n        });\n    };\n    Decoder.prototype.decodeUtf8String = function (byteLength, headerOffset) {\n        var _a;\n        if (byteLength > this.maxStrLength) {\n            throw new DecodeError(\"Max length exceeded: UTF-8 byte length (\".concat(byteLength, \") > maxStrLength (\").concat(this.maxStrLength, \")\"));\n        }\n        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n            throw MORE_DATA;\n        }\n        var offset = this.pos + headerOffset;\n        var object;\n        if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {\n            object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n        }\n        else if (byteLength > TEXT_DECODER_THRESHOLD) {\n            object = utf8DecodeTD(this.bytes, offset, byteLength);\n        }\n        else {\n            object = utf8DecodeJs(this.bytes, offset, byteLength);\n        }\n        this.pos += headerOffset + byteLength;\n        return object;\n    };\n    Decoder.prototype.stateIsMapKey = function () {\n        if (this.stack.length > 0) {\n            var state = this.stack[this.stack.length - 1];\n            return state.type === 1 /* State.MAP_KEY */;\n        }\n        return false;\n    };\n    Decoder.prototype.decodeBinary = function (byteLength, headOffset) {\n        if (byteLength > this.maxBinLength) {\n            throw new DecodeError(\"Max length exceeded: bin length (\".concat(byteLength, \") > maxBinLength (\").concat(this.maxBinLength, \")\"));\n        }\n        if (!this.hasRemaining(byteLength + headOffset)) {\n            throw MORE_DATA;\n        }\n        var offset = this.pos + headOffset;\n        var object = this.bytes.subarray(offset, offset + byteLength);\n        this.pos += headOffset + byteLength;\n        return object;\n    };\n    Decoder.prototype.decodeExtension = function (size, headOffset) {\n        if (size > this.maxExtLength) {\n            throw new DecodeError(\"Max length exceeded: ext length (\".concat(size, \") > maxExtLength (\").concat(this.maxExtLength, \")\"));\n        }\n        var extType = this.view.getInt8(this.pos + headOffset);\n        var data = this.decodeBinary(size, headOffset + 1 /* extType */);\n        return this.extensionCodec.decode(data, extType, this.context);\n    };\n    Decoder.prototype.lookU8 = function () {\n        return this.view.getUint8(this.pos);\n    };\n    Decoder.prototype.lookU16 = function () {\n        return this.view.getUint16(this.pos);\n    };\n    Decoder.prototype.lookU32 = function () {\n        return this.view.getUint32(this.pos);\n    };\n    Decoder.prototype.readU8 = function () {\n        var value = this.view.getUint8(this.pos);\n        this.pos++;\n        return value;\n    };\n    Decoder.prototype.readI8 = function () {\n        var value = this.view.getInt8(this.pos);\n        this.pos++;\n        return value;\n    };\n    Decoder.prototype.readU16 = function () {\n        var value = this.view.getUint16(this.pos);\n        this.pos += 2;\n        return value;\n    };\n    Decoder.prototype.readI16 = function () {\n        var value = this.view.getInt16(this.pos);\n        this.pos += 2;\n        return value;\n    };\n    Decoder.prototype.readU32 = function () {\n        var value = this.view.getUint32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readI32 = function () {\n        var value = this.view.getInt32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readU64 = function () {\n        var value = getUint64(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readI64 = function () {\n        var value = getInt64(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readF32 = function () {\n        var value = this.view.getFloat32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readF64 = function () {\n        var value = this.view.getFloat64(this.pos);\n        this.pos += 8;\n        return value;\n    };\n    return Decoder;\n}());\nexport { Decoder };\n//# sourceMappingURL=Decoder.mjs.map","import { prettyByte } from \"./utils/prettyByte\";\nimport { ExtensionCodec, ExtensionCodecType } from \"./ExtensionCodec\";\nimport { getInt64, getUint64, UINT32_MAX } from \"./utils/int\";\nimport { utf8DecodeJs, TEXT_DECODER_THRESHOLD, utf8DecodeTD } from \"./utils/utf8\";\nimport { createDataView, ensureUint8Array } from \"./utils/typedArrays\";\nimport { CachedKeyDecoder, KeyDecoder } from \"./CachedKeyDecoder\";\nimport { DecodeError } from \"./DecodeError\";\n\nconst enum State {\n  ARRAY,\n  MAP_KEY,\n  MAP_VALUE,\n}\n\ntype MapKeyType = string | number;\n\nconst isValidMapKeyType = (key: unknown): key is MapKeyType => {\n  const keyType = typeof key;\n\n  return keyType === \"string\" || keyType === \"number\";\n};\n\ntype StackMapState = {\n  type: State.MAP_KEY | State.MAP_VALUE;\n  size: number;\n  key: MapKeyType | null;\n  readCount: number;\n  map: Record<string, unknown>;\n};\n\ntype StackArrayState = {\n  type: State.ARRAY;\n  size: number;\n  array: Array<unknown>;\n  position: number;\n};\n\ntype StackState = StackArrayState | StackMapState;\n\nconst HEAD_BYTE_REQUIRED = -1;\n\nconst EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nconst EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n\n// IE11: Hack to support IE11.\n// IE11: Drop this hack and just use RangeError when IE11 is obsolete.\nexport const DataViewIndexOutOfBoundsError: typeof Error = (() => {\n  try {\n    // IE11: The spec says it should throw RangeError,\n    // IE11: but in IE11 it throws TypeError.\n    EMPTY_VIEW.getInt8(0);\n  } catch (e: any) {\n    return e.constructor;\n  }\n  throw new Error(\"never reached\");\n})();\n\nconst MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\n\nconst sharedCachedKeyDecoder = new CachedKeyDecoder();\n\nexport class Decoder<ContextType = undefined> {\n  private totalPos = 0;\n  private pos = 0;\n\n  private view = EMPTY_VIEW;\n  private bytes = EMPTY_BYTES;\n  private headByte = HEAD_BYTE_REQUIRED;\n  private readonly stack: Array<StackState> = [];\n\n  public constructor(\n    private readonly extensionCodec: ExtensionCodecType<ContextType> = ExtensionCodec.defaultCodec as any,\n    private readonly context: ContextType = undefined as any,\n    private readonly maxStrLength = UINT32_MAX,\n    private readonly maxBinLength = UINT32_MAX,\n    private readonly maxArrayLength = UINT32_MAX,\n    private readonly maxMapLength = UINT32_MAX,\n    private readonly maxExtLength = UINT32_MAX,\n    private readonly keyDecoder: KeyDecoder | null = sharedCachedKeyDecoder,\n  ) {}\n\n  private reinitializeState() {\n    this.totalPos = 0;\n    this.headByte = HEAD_BYTE_REQUIRED;\n    this.stack.length = 0;\n\n    // view, bytes, and pos will be re-initialized in setBuffer()\n  }\n\n  private setBuffer(buffer: ArrayLike<number> | BufferSource): void {\n    this.bytes = ensureUint8Array(buffer);\n    this.view = createDataView(this.bytes);\n    this.pos = 0;\n  }\n\n  private appendBuffer(buffer: ArrayLike<number> | BufferSource) {\n    if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n      this.setBuffer(buffer);\n    } else {\n      const remainingData = this.bytes.subarray(this.pos);\n      const newData = ensureUint8Array(buffer);\n\n      // concat remainingData + newData\n      const newBuffer = new Uint8Array(remainingData.length + newData.length);\n      newBuffer.set(remainingData);\n      newBuffer.set(newData, remainingData.length);\n      this.setBuffer(newBuffer);\n    }\n  }\n\n  private hasRemaining(size: number) {\n    return this.view.byteLength - this.pos >= size;\n  }\n\n  private createExtraByteError(posToShow: number): Error {\n    const { view, pos } = this;\n    return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);\n  }\n\n  /**\n   * @throws {@link DecodeError}\n   * @throws {@link RangeError}\n   */\n  public decode(buffer: ArrayLike<number> | BufferSource): unknown {\n    this.reinitializeState();\n    this.setBuffer(buffer);\n\n    const object = this.doDecodeSync();\n    if (this.hasRemaining(1)) {\n      throw this.createExtraByteError(this.pos);\n    }\n    return object;\n  }\n\n  public *decodeMulti(buffer: ArrayLike<number> | BufferSource): Generator<unknown, void, unknown> {\n    this.reinitializeState();\n    this.setBuffer(buffer);\n\n    while (this.hasRemaining(1)) {\n      yield this.doDecodeSync();\n    }\n  }\n\n  public async decodeAsync(stream: AsyncIterable<ArrayLike<number> | BufferSource>): Promise<unknown> {\n    let decoded = false;\n    let object: unknown;\n    for await (const buffer of stream) {\n      if (decoded) {\n        throw this.createExtraByteError(this.totalPos);\n      }\n\n      this.appendBuffer(buffer);\n\n      try {\n        object = this.doDecodeSync();\n        decoded = true;\n      } catch (e) {\n        if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n          throw e; // rethrow\n        }\n        // fallthrough\n      }\n      this.totalPos += this.pos;\n    }\n\n    if (decoded) {\n      if (this.hasRemaining(1)) {\n        throw this.createExtraByteError(this.totalPos);\n      }\n      return object;\n    }\n\n    const { headByte, pos, totalPos } = this;\n    throw new RangeError(\n      `Insufficient data in parsing ${prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`,\n    );\n  }\n\n  public decodeArrayStream(\n    stream: AsyncIterable<ArrayLike<number> | BufferSource>,\n  ): AsyncGenerator<unknown, void, unknown> {\n    return this.decodeMultiAsync(stream, true);\n  }\n\n  public decodeStream(stream: AsyncIterable<ArrayLike<number> | BufferSource>): AsyncGenerator<unknown, void, unknown> {\n    return this.decodeMultiAsync(stream, false);\n  }\n\n  private async *decodeMultiAsync(stream: AsyncIterable<ArrayLike<number> | BufferSource>, isArray: boolean) {\n    let isArrayHeaderRequired = isArray;\n    let arrayItemsLeft = -1;\n\n    for await (const buffer of stream) {\n      if (isArray && arrayItemsLeft === 0) {\n        throw this.createExtraByteError(this.totalPos);\n      }\n\n      this.appendBuffer(buffer);\n\n      if (isArrayHeaderRequired) {\n        arrayItemsLeft = this.readArraySize();\n        isArrayHeaderRequired = false;\n        this.complete();\n      }\n\n      try {\n        while (true) {\n          yield this.doDecodeSync();\n          if (--arrayItemsLeft === 0) {\n            break;\n          }\n        }\n      } catch (e) {\n        if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n          throw e; // rethrow\n        }\n        // fallthrough\n      }\n      this.totalPos += this.pos;\n    }\n  }\n\n  private doDecodeSync(): unknown {\n    DECODE: while (true) {\n      const headByte = this.readHeadByte();\n      let object: unknown;\n\n      if (headByte >= 0xe0) {\n        // negative fixint (111x xxxx) 0xe0 - 0xff\n        object = headByte - 0x100;\n      } else if (headByte < 0xc0) {\n        if (headByte < 0x80) {\n          // positive fixint (0xxx xxxx) 0x00 - 0x7f\n          object = headByte;\n        } else if (headByte < 0x90) {\n          // fixmap (1000 xxxx) 0x80 - 0x8f\n          const size = headByte - 0x80;\n          if (size !== 0) {\n            this.pushMapState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = {};\n          }\n        } else if (headByte < 0xa0) {\n          // fixarray (1001 xxxx) 0x90 - 0x9f\n          const size = headByte - 0x90;\n          if (size !== 0) {\n            this.pushArrayState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = [];\n          }\n        } else {\n          // fixstr (101x xxxx) 0xa0 - 0xbf\n          const byteLength = headByte - 0xa0;\n          object = this.decodeUtf8String(byteLength, 0);\n        }\n      } else if (headByte === 0xc0) {\n        // nil\n        object = null;\n      } else if (headByte === 0xc2) {\n        // false\n        object = false;\n      } else if (headByte === 0xc3) {\n        // true\n        object = true;\n      } else if (headByte === 0xca) {\n        // float 32\n        object = this.readF32();\n      } else if (headByte === 0xcb) {\n        // float 64\n        object = this.readF64();\n      } else if (headByte === 0xcc) {\n        // uint 8\n        object = this.readU8();\n      } else if (headByte === 0xcd) {\n        // uint 16\n        object = this.readU16();\n      } else if (headByte === 0xce) {\n        // uint 32\n        object = this.readU32();\n      } else if (headByte === 0xcf) {\n        // uint 64\n        object = this.readU64();\n      } else if (headByte === 0xd0) {\n        // int 8\n        object = this.readI8();\n      } else if (headByte === 0xd1) {\n        // int 16\n        object = this.readI16();\n      } else if (headByte === 0xd2) {\n        // int 32\n        object = this.readI32();\n      } else if (headByte === 0xd3) {\n        // int 64\n        object = this.readI64();\n      } else if (headByte === 0xd9) {\n        // str 8\n        const byteLength = this.lookU8();\n        object = this.decodeUtf8String(byteLength, 1);\n      } else if (headByte === 0xda) {\n        // str 16\n        const byteLength = this.lookU16();\n        object = this.decodeUtf8String(byteLength, 2);\n      } else if (headByte === 0xdb) {\n        // str 32\n        const byteLength = this.lookU32();\n        object = this.decodeUtf8String(byteLength, 4);\n      } else if (headByte === 0xdc) {\n        // array 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xdd) {\n        // array 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xde) {\n        // map 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xdf) {\n        // map 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xc4) {\n        // bin 8\n        const size = this.lookU8();\n        object = this.decodeBinary(size, 1);\n      } else if (headByte === 0xc5) {\n        // bin 16\n        const size = this.lookU16();\n        object = this.decodeBinary(size, 2);\n      } else if (headByte === 0xc6) {\n        // bin 32\n        const size = this.lookU32();\n        object = this.decodeBinary(size, 4);\n      } else if (headByte === 0xd4) {\n        // fixext 1\n        object = this.decodeExtension(1, 0);\n      } else if (headByte === 0xd5) {\n        // fixext 2\n        object = this.decodeExtension(2, 0);\n      } else if (headByte === 0xd6) {\n        // fixext 4\n        object = this.decodeExtension(4, 0);\n      } else if (headByte === 0xd7) {\n        // fixext 8\n        object = this.decodeExtension(8, 0);\n      } else if (headByte === 0xd8) {\n        // fixext 16\n        object = this.decodeExtension(16, 0);\n      } else if (headByte === 0xc7) {\n        // ext 8\n        const size = this.lookU8();\n        object = this.decodeExtension(size, 1);\n      } else if (headByte === 0xc8) {\n        // ext 16\n        const size = this.lookU16();\n        object = this.decodeExtension(size, 2);\n      } else if (headByte === 0xc9) {\n        // ext 32\n        const size = this.lookU32();\n        object = this.decodeExtension(size, 4);\n      } else {\n        throw new DecodeError(`Unrecognized type byte: ${prettyByte(headByte)}`);\n      }\n\n      this.complete();\n\n      const stack = this.stack;\n      while (stack.length > 0) {\n        // arrays and maps\n        const state = stack[stack.length - 1]!;\n        if (state.type === State.ARRAY) {\n          state.array[state.position] = object;\n          state.position++;\n          if (state.position === state.size) {\n            stack.pop();\n            object = state.array;\n          } else {\n            continue DECODE;\n          }\n        } else if (state.type === State.MAP_KEY) {\n          if (!isValidMapKeyType(object)) {\n            throw new DecodeError(\"The type of key must be string or number but \" + typeof object);\n          }\n          if (object === \"__proto__\") {\n            throw new DecodeError(\"The key __proto__ is not allowed\");\n          }\n\n          state.key = object;\n          state.type = State.MAP_VALUE;\n          continue DECODE;\n        } else {\n          // it must be `state.type === State.MAP_VALUE` here\n\n          state.map[state.key!] = object;\n          state.readCount++;\n\n          if (state.readCount === state.size) {\n            stack.pop();\n            object = state.map;\n          } else {\n            state.key = null;\n            state.type = State.MAP_KEY;\n            continue DECODE;\n          }\n        }\n      }\n\n      return object;\n    }\n  }\n\n  private readHeadByte(): number {\n    if (this.headByte === HEAD_BYTE_REQUIRED) {\n      this.headByte = this.readU8();\n      // console.log(\"headByte\", prettyByte(this.headByte));\n    }\n\n    return this.headByte;\n  }\n\n  private complete(): void {\n    this.headByte = HEAD_BYTE_REQUIRED;\n  }\n\n  private readArraySize(): number {\n    const headByte = this.readHeadByte();\n\n    switch (headByte) {\n      case 0xdc:\n        return this.readU16();\n      case 0xdd:\n        return this.readU32();\n      default: {\n        if (headByte < 0xa0) {\n          return headByte - 0x90;\n        } else {\n          throw new DecodeError(`Unrecognized array type byte: ${prettyByte(headByte)}`);\n        }\n      }\n    }\n  }\n\n  private pushMapState(size: number) {\n    if (size > this.maxMapLength) {\n      throw new DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);\n    }\n\n    this.stack.push({\n      type: State.MAP_KEY,\n      size,\n      key: null,\n      readCount: 0,\n      map: {},\n    });\n  }\n\n  private pushArrayState(size: number) {\n    if (size > this.maxArrayLength) {\n      throw new DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);\n    }\n\n    this.stack.push({\n      type: State.ARRAY,\n      size,\n      array: new Array<unknown>(size),\n      position: 0,\n    });\n  }\n\n  private decodeUtf8String(byteLength: number, headerOffset: number): string {\n    if (byteLength > this.maxStrLength) {\n      throw new DecodeError(\n        `Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`,\n      );\n    }\n\n    if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headerOffset;\n    let object: string;\n    if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength)) {\n      object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n    } else if (byteLength > TEXT_DECODER_THRESHOLD) {\n      object = utf8DecodeTD(this.bytes, offset, byteLength);\n    } else {\n      object = utf8DecodeJs(this.bytes, offset, byteLength);\n    }\n    this.pos += headerOffset + byteLength;\n    return object;\n  }\n\n  private stateIsMapKey(): boolean {\n    if (this.stack.length > 0) {\n      const state = this.stack[this.stack.length - 1]!;\n      return state.type === State.MAP_KEY;\n    }\n    return false;\n  }\n\n  private decodeBinary(byteLength: number, headOffset: number): Uint8Array {\n    if (byteLength > this.maxBinLength) {\n      throw new DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);\n    }\n\n    if (!this.hasRemaining(byteLength + headOffset)) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headOffset;\n    const object = this.bytes.subarray(offset, offset + byteLength);\n    this.pos += headOffset + byteLength;\n    return object;\n  }\n\n  private decodeExtension(size: number, headOffset: number): unknown {\n    if (size > this.maxExtLength) {\n      throw new DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);\n    }\n\n    const extType = this.view.getInt8(this.pos + headOffset);\n    const data = this.decodeBinary(size, headOffset + 1 /* extType */);\n    return this.extensionCodec.decode(data, extType, this.context);\n  }\n\n  private lookU8() {\n    return this.view.getUint8(this.pos);\n  }\n\n  private lookU16() {\n    return this.view.getUint16(this.pos);\n  }\n\n  private lookU32() {\n    return this.view.getUint32(this.pos);\n  }\n\n  private readU8(): number {\n    const value = this.view.getUint8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  private readI8(): number {\n    const value = this.view.getInt8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  private readU16(): number {\n    const value = this.view.getUint16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  private readI16(): number {\n    const value = this.view.getInt16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  private readU32(): number {\n    const value = this.view.getUint32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readI32(): number {\n    const value = this.view.getInt32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readU64(): number {\n    const value = getUint64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readI64(): number {\n    const value = getInt64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readF32() {\n    const value = this.view.getFloat32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readF64() {\n    const value = this.view.getFloat64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n}\n","export function prettyByte(byte) {\n    return \"\".concat(byte < 0 ? \"-\" : \"\", \"0x\").concat(Math.abs(byte).toString(16).padStart(2, \"0\"));\n}\n//# sourceMappingURL=prettyByte.mjs.map","export function prettyByte(byte: number): string {\n  return `${byte < 0 ? \"-\" : \"\"}0x${Math.abs(byte).toString(16).padStart(2, \"0\")}`;\n}\n","// ExtensionCodec to handle MessagePack extensions\nimport { ExtData } from \"./ExtData.mjs\";\nimport { timestampExtension } from \"./timestamp.mjs\";\nvar ExtensionCodec = /** @class */ (function () {\n    function ExtensionCodec() {\n        // built-in extensions\n        this.builtInEncoders = [];\n        this.builtInDecoders = [];\n        // custom extensions\n        this.encoders = [];\n        this.decoders = [];\n        this.register(timestampExtension);\n    }\n    ExtensionCodec.prototype.register = function (_a) {\n        var type = _a.type, encode = _a.encode, decode = _a.decode;\n        if (type >= 0) {\n            // custom extensions\n            this.encoders[type] = encode;\n            this.decoders[type] = decode;\n        }\n        else {\n            // built-in extensions\n            var index = 1 + type;\n            this.builtInEncoders[index] = encode;\n            this.builtInDecoders[index] = decode;\n        }\n    };\n    ExtensionCodec.prototype.tryToEncode = function (object, context) {\n        // built-in extensions\n        for (var i = 0; i < this.builtInEncoders.length; i++) {\n            var encodeExt = this.builtInEncoders[i];\n            if (encodeExt != null) {\n                var data = encodeExt(object, context);\n                if (data != null) {\n                    var type = -1 - i;\n                    return new ExtData(type, data);\n                }\n            }\n        }\n        // custom extensions\n        for (var i = 0; i < this.encoders.length; i++) {\n            var encodeExt = this.encoders[i];\n            if (encodeExt != null) {\n                var data = encodeExt(object, context);\n                if (data != null) {\n                    var type = i;\n                    return new ExtData(type, data);\n                }\n            }\n        }\n        if (object instanceof ExtData) {\n            // to keep ExtData as is\n            return object;\n        }\n        return null;\n    };\n    ExtensionCodec.prototype.decode = function (data, type, context) {\n        var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n        if (decodeExt) {\n            return decodeExt(data, type, context);\n        }\n        else {\n            // decode() does not fail, returns ExtData instead.\n            return new ExtData(type, data);\n        }\n    };\n    ExtensionCodec.defaultCodec = new ExtensionCodec();\n    return ExtensionCodec;\n}());\nexport { ExtensionCodec };\n//# sourceMappingURL=ExtensionCodec.mjs.map","// ExtensionCodec to handle MessagePack extensions\n\nimport { ExtData } from \"./ExtData\";\nimport { timestampExtension } from \"./timestamp\";\n\nexport type ExtensionDecoderType<ContextType> = (\n  data: Uint8Array,\n  extensionType: number,\n  context: ContextType,\n) => unknown;\n\nexport type ExtensionEncoderType<ContextType> = (input: unknown, context: ContextType) => Uint8Array | null;\n\n// immutable interface to ExtensionCodec\nexport type ExtensionCodecType<ContextType> = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  __brand?: ContextType;\n  tryToEncode(object: unknown, context: ContextType): ExtData | null;\n  decode(data: Uint8Array, extType: number, context: ContextType): unknown;\n};\n\nexport class ExtensionCodec<ContextType = undefined> implements ExtensionCodecType<ContextType> {\n  public static readonly defaultCodec: ExtensionCodecType<undefined> = new ExtensionCodec();\n\n  // ensures ExtensionCodecType<X> matches ExtensionCodec<X>\n  // this will make type errors a lot more clear\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  __brand?: ContextType;\n\n  // built-in extensions\n  private readonly builtInEncoders: Array<ExtensionEncoderType<ContextType> | undefined | null> = [];\n  private readonly builtInDecoders: Array<ExtensionDecoderType<ContextType> | undefined | null> = [];\n\n  // custom extensions\n  private readonly encoders: Array<ExtensionEncoderType<ContextType> | undefined | null> = [];\n  private readonly decoders: Array<ExtensionDecoderType<ContextType> | undefined | null> = [];\n\n  public constructor() {\n    this.register(timestampExtension);\n  }\n\n  public register({\n    type,\n    encode,\n    decode,\n  }: {\n    type: number;\n    encode: ExtensionEncoderType<ContextType>;\n    decode: ExtensionDecoderType<ContextType>;\n  }): void {\n    if (type >= 0) {\n      // custom extensions\n      this.encoders[type] = encode;\n      this.decoders[type] = decode;\n    } else {\n      // built-in extensions\n      const index = 1 + type;\n      this.builtInEncoders[index] = encode;\n      this.builtInDecoders[index] = decode;\n    }\n  }\n\n  public tryToEncode(object: unknown, context: ContextType): ExtData | null {\n    // built-in extensions\n    for (let i = 0; i < this.builtInEncoders.length; i++) {\n      const encodeExt = this.builtInEncoders[i];\n      if (encodeExt != null) {\n        const data = encodeExt(object, context);\n        if (data != null) {\n          const type = -1 - i;\n          return new ExtData(type, data);\n        }\n      }\n    }\n\n    // custom extensions\n    for (let i = 0; i < this.encoders.length; i++) {\n      const encodeExt = this.encoders[i];\n      if (encodeExt != null) {\n        const data = encodeExt(object, context);\n        if (data != null) {\n          const type = i;\n          return new ExtData(type, data);\n        }\n      }\n    }\n\n    if (object instanceof ExtData) {\n      // to keep ExtData as is\n      return object;\n    }\n    return null;\n  }\n\n  public decode(data: Uint8Array, type: number, context: ContextType): unknown {\n    const decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n    if (decodeExt) {\n      return decodeExt(data, type, context);\n    } else {\n      // decode() does not fail, returns ExtData instead.\n      return new ExtData(type, data);\n    }\n  }\n}\n","/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */\nvar ExtData = /** @class */ (function () {\n    function ExtData(type, data) {\n        this.type = type;\n        this.data = data;\n    }\n    return ExtData;\n}());\nexport { ExtData };\n//# sourceMappingURL=ExtData.mjs.map","/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */\nexport class ExtData {\n  constructor(readonly type: number, readonly data: Uint8Array) {}\n}\n","// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\nimport { DecodeError } from \"./DecodeError.mjs\";\nimport { getInt64, setInt64 } from \"./utils/int.mjs\";\nexport var EXT_TIMESTAMP = -1;\nvar TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\nvar TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\nexport function encodeTimeSpecToTimestamp(_a) {\n    var sec = _a.sec, nsec = _a.nsec;\n    if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n        // Here sec >= 0 && nsec >= 0\n        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n            // timestamp 32 = { sec32 (unsigned) }\n            var rv = new Uint8Array(4);\n            var view = new DataView(rv.buffer);\n            view.setUint32(0, sec);\n            return rv;\n        }\n        else {\n            // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n            var secHigh = sec / 0x100000000;\n            var secLow = sec & 0xffffffff;\n            var rv = new Uint8Array(8);\n            var view = new DataView(rv.buffer);\n            // nsec30 | secHigh2\n            view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\n            // secLow32\n            view.setUint32(4, secLow);\n            return rv;\n        }\n    }\n    else {\n        // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n        var rv = new Uint8Array(12);\n        var view = new DataView(rv.buffer);\n        view.setUint32(0, nsec);\n        setInt64(view, 4, sec);\n        return rv;\n    }\n}\nexport function encodeDateToTimeSpec(date) {\n    var msec = date.getTime();\n    var sec = Math.floor(msec / 1e3);\n    var nsec = (msec - sec * 1e3) * 1e6;\n    // Normalizes { sec, nsec } to ensure nsec is unsigned.\n    var nsecInSec = Math.floor(nsec / 1e9);\n    return {\n        sec: sec + nsecInSec,\n        nsec: nsec - nsecInSec * 1e9,\n    };\n}\nexport function encodeTimestampExtension(object) {\n    if (object instanceof Date) {\n        var timeSpec = encodeDateToTimeSpec(object);\n        return encodeTimeSpecToTimestamp(timeSpec);\n    }\n    else {\n        return null;\n    }\n}\nexport function decodeTimestampToTimeSpec(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    // data may be 32, 64, or 96 bits\n    switch (data.byteLength) {\n        case 4: {\n            // timestamp 32 = { sec32 }\n            var sec = view.getUint32(0);\n            var nsec = 0;\n            return { sec: sec, nsec: nsec };\n        }\n        case 8: {\n            // timestamp 64 = { nsec30, sec34 }\n            var nsec30AndSecHigh2 = view.getUint32(0);\n            var secLow32 = view.getUint32(4);\n            var sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n            var nsec = nsec30AndSecHigh2 >>> 2;\n            return { sec: sec, nsec: nsec };\n        }\n        case 12: {\n            // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n            var sec = getInt64(view, 4);\n            var nsec = view.getUint32(0);\n            return { sec: sec, nsec: nsec };\n        }\n        default:\n            throw new DecodeError(\"Unrecognized data size for timestamp (expected 4, 8, or 12): \".concat(data.length));\n    }\n}\nexport function decodeTimestampExtension(data) {\n    var timeSpec = decodeTimestampToTimeSpec(data);\n    return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\nexport var timestampExtension = {\n    type: EXT_TIMESTAMP,\n    encode: encodeTimestampExtension,\n    decode: decodeTimestampExtension,\n};\n//# sourceMappingURL=timestamp.mjs.map","// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\nimport { DecodeError } from \"./DecodeError\";\nimport { getInt64, setInt64 } from \"./utils/int\";\n\nexport const EXT_TIMESTAMP = -1;\n\nexport type TimeSpec = {\n  sec: number;\n  nsec: number;\n};\n\nconst TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\nconst TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\n\nexport function encodeTimeSpecToTimestamp({ sec, nsec }: TimeSpec): Uint8Array {\n  if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n    // Here sec >= 0 && nsec >= 0\n    if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n      // timestamp 32 = { sec32 (unsigned) }\n      const rv = new Uint8Array(4);\n      const view = new DataView(rv.buffer);\n      view.setUint32(0, sec);\n      return rv;\n    } else {\n      // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n      const secHigh = sec / 0x100000000;\n      const secLow = sec & 0xffffffff;\n      const rv = new Uint8Array(8);\n      const view = new DataView(rv.buffer);\n      // nsec30 | secHigh2\n      view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\n      // secLow32\n      view.setUint32(4, secLow);\n      return rv;\n    }\n  } else {\n    // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n    const rv = new Uint8Array(12);\n    const view = new DataView(rv.buffer);\n    view.setUint32(0, nsec);\n    setInt64(view, 4, sec);\n    return rv;\n  }\n}\n\nexport function encodeDateToTimeSpec(date: Date): TimeSpec {\n  const msec = date.getTime();\n  const sec = Math.floor(msec / 1e3);\n  const nsec = (msec - sec * 1e3) * 1e6;\n\n  // Normalizes { sec, nsec } to ensure nsec is unsigned.\n  const nsecInSec = Math.floor(nsec / 1e9);\n  return {\n    sec: sec + nsecInSec,\n    nsec: nsec - nsecInSec * 1e9,\n  };\n}\n\nexport function encodeTimestampExtension(object: unknown): Uint8Array | null {\n  if (object instanceof Date) {\n    const timeSpec = encodeDateToTimeSpec(object);\n    return encodeTimeSpecToTimestamp(timeSpec);\n  } else {\n    return null;\n  }\n}\n\nexport function decodeTimestampToTimeSpec(data: Uint8Array): TimeSpec {\n  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\n  // data may be 32, 64, or 96 bits\n  switch (data.byteLength) {\n    case 4: {\n      // timestamp 32 = { sec32 }\n      const sec = view.getUint32(0);\n      const nsec = 0;\n      return { sec, nsec };\n    }\n    case 8: {\n      // timestamp 64 = { nsec30, sec34 }\n      const nsec30AndSecHigh2 = view.getUint32(0);\n      const secLow32 = view.getUint32(4);\n      const sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n      const nsec = nsec30AndSecHigh2 >>> 2;\n      return { sec, nsec };\n    }\n    case 12: {\n      // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n\n      const sec = getInt64(view, 4);\n      const nsec = view.getUint32(0);\n      return { sec, nsec };\n    }\n    default:\n      throw new DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);\n  }\n}\n\nexport function decodeTimestampExtension(data: Uint8Array): Date {\n  const timeSpec = decodeTimestampToTimeSpec(data);\n  return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\n\nexport const timestampExtension = {\n  type: EXT_TIMESTAMP,\n  encode: encodeTimestampExtension,\n  decode: decodeTimestampExtension,\n};\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar DecodeError = /** @class */ (function (_super) {\n    __extends(DecodeError, _super);\n    function DecodeError(message) {\n        var _this = _super.call(this, message) || this;\n        // fix the prototype chain in a cross-platform way\n        var proto = Object.create(DecodeError.prototype);\n        Object.setPrototypeOf(_this, proto);\n        Object.defineProperty(_this, \"name\", {\n            configurable: true,\n            enumerable: false,\n            value: DecodeError.name,\n        });\n        return _this;\n    }\n    return DecodeError;\n}(Error));\nexport { DecodeError };\n//# sourceMappingURL=DecodeError.mjs.map","export class DecodeError extends Error {\n  constructor(message: string) {\n    super(message);\n\n    // fix the prototype chain in a cross-platform way\n    const proto: typeof DecodeError.prototype = Object.create(DecodeError.prototype);\n    Object.setPrototypeOf(this, proto);\n\n    Object.defineProperty(this, \"name\", {\n      configurable: true,\n      enumerable: false,\n      value: DecodeError.name,\n    });\n  }\n}\n","// Integer Utility\nexport var UINT32_MAX = 4294967295;\n// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\nexport function setUint64(view, offset, value) {\n    var high = value / 4294967296;\n    var low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nexport function setInt64(view, offset, value) {\n    var high = Math.floor(value / 4294967296);\n    var low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nexport function getInt64(view, offset) {\n    var high = view.getInt32(offset);\n    var low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\nexport function getUint64(view, offset) {\n    var high = view.getUint32(offset);\n    var low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\n//# sourceMappingURL=int.mjs.map","// Integer Utility\n\nexport const UINT32_MAX = 0xffff_ffff;\n\n// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\n\nexport function setUint64(view: DataView, offset: number, value: number): void {\n  const high = value / 0x1_0000_0000;\n  const low = value; // high bits are truncated by DataView\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\n\nexport function setInt64(view: DataView, offset: number, value: number): void {\n  const high = Math.floor(value / 0x1_0000_0000);\n  const low = value; // high bits are truncated by DataView\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\n\nexport function getInt64(view: DataView, offset: number): number {\n  const high = view.getInt32(offset);\n  const low = view.getUint32(offset + 4);\n  return high * 0x1_0000_0000 + low;\n}\n\nexport function getUint64(view: DataView, offset: number): number {\n  const high = view.getUint32(offset);\n  const low = view.getUint32(offset + 4);\n  return high * 0x1_0000_0000 + low;\n}\n","var _a, _b, _c;\n/* eslint-disable @typescript-eslint/no-unnecessary-condition */\nimport { UINT32_MAX } from \"./int.mjs\";\nvar TEXT_ENCODING_AVAILABLE = (typeof process === \"undefined\" || ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a[\"TEXT_ENCODING\"]) !== \"never\") &&\n    typeof TextEncoder !== \"undefined\" &&\n    typeof TextDecoder !== \"undefined\";\nexport function utf8Count(str) {\n    var strLength = str.length;\n    var byteLength = 0;\n    var pos = 0;\n    while (pos < strLength) {\n        var value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            byteLength++;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            byteLength += 2;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                byteLength += 3;\n            }\n            else {\n                // 4-byte\n                byteLength += 4;\n            }\n        }\n    }\n    return byteLength;\n}\nexport function utf8EncodeJs(str, output, outputOffset) {\n    var strLength = str.length;\n    var offset = outputOffset;\n    var pos = 0;\n    while (pos < strLength) {\n        var value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            output[offset++] = value;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n            else {\n                // 4-byte\n                output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n                output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n        }\n        output[offset++] = (value & 0x3f) | 0x80;\n    }\n}\nvar sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : undefined;\nexport var TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE\n    ? UINT32_MAX\n    : typeof process !== \"undefined\" && ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b[\"TEXT_ENCODING\"]) !== \"force\"\n        ? 200\n        : 0;\nfunction utf8EncodeTEencode(str, output, outputOffset) {\n    output.set(sharedTextEncoder.encode(str), outputOffset);\n}\nfunction utf8EncodeTEencodeInto(str, output, outputOffset) {\n    sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n}\nexport var utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;\nvar CHUNK_SIZE = 4096;\nexport function utf8DecodeJs(bytes, inputOffset, byteLength) {\n    var offset = inputOffset;\n    var end = offset + byteLength;\n    var units = [];\n    var result = \"\";\n    while (offset < end) {\n        var byte1 = bytes[offset++];\n        if ((byte1 & 0x80) === 0) {\n            // 1 byte\n            units.push(byte1);\n        }\n        else if ((byte1 & 0xe0) === 0xc0) {\n            // 2 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 6) | byte2);\n        }\n        else if ((byte1 & 0xf0) === 0xe0) {\n            // 3 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            var byte3 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n        }\n        else if ((byte1 & 0xf8) === 0xf0) {\n            // 4 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            var byte3 = bytes[offset++] & 0x3f;\n            var byte4 = bytes[offset++] & 0x3f;\n            var unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n            if (unit > 0xffff) {\n                unit -= 0x10000;\n                units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n                unit = 0xdc00 | (unit & 0x3ff);\n            }\n            units.push(unit);\n        }\n        else {\n            units.push(byte1);\n        }\n        if (units.length >= CHUNK_SIZE) {\n            result += String.fromCharCode.apply(String, units);\n            units.length = 0;\n        }\n    }\n    if (units.length > 0) {\n        result += String.fromCharCode.apply(String, units);\n    }\n    return result;\n}\nvar sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;\nexport var TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE\n    ? UINT32_MAX\n    : typeof process !== \"undefined\" && ((_c = process === null || process === void 0 ? void 0 : process.env) === null || _c === void 0 ? void 0 : _c[\"TEXT_DECODER\"]) !== \"force\"\n        ? 200\n        : 0;\nexport function utf8DecodeTD(bytes, inputOffset, byteLength) {\n    var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n    return sharedTextDecoder.decode(stringBytes);\n}\n//# sourceMappingURL=utf8.mjs.map","/* eslint-disable @typescript-eslint/no-unnecessary-condition */\nimport { UINT32_MAX } from \"./int\";\n\nconst TEXT_ENCODING_AVAILABLE =\n  (typeof process === \"undefined\" || process?.env?.[\"TEXT_ENCODING\"] !== \"never\") &&\n  typeof TextEncoder !== \"undefined\" &&\n  typeof TextDecoder !== \"undefined\";\n\nexport function utf8Count(str: string): number {\n  const strLength = str.length;\n\n  let byteLength = 0;\n  let pos = 0;\n  while (pos < strLength) {\n    let value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      byteLength++;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      byteLength += 2;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          const extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        byteLength += 3;\n      } else {\n        // 4-byte\n        byteLength += 4;\n      }\n    }\n  }\n  return byteLength;\n}\n\nexport function utf8EncodeJs(str: string, output: Uint8Array, outputOffset: number): void {\n  const strLength = str.length;\n  let offset = outputOffset;\n  let pos = 0;\n  while (pos < strLength) {\n    let value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      output[offset++] = value;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          const extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n      } else {\n        // 4-byte\n        output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n        output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n      }\n    }\n\n    output[offset++] = (value & 0x3f) | 0x80;\n  }\n}\n\nconst sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : undefined;\nexport const TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE\n  ? UINT32_MAX\n  : typeof process !== \"undefined\" && process?.env?.[\"TEXT_ENCODING\"] !== \"force\"\n  ? 200\n  : 0;\n\nfunction utf8EncodeTEencode(str: string, output: Uint8Array, outputOffset: number): void {\n  output.set(sharedTextEncoder!.encode(str), outputOffset);\n}\n\nfunction utf8EncodeTEencodeInto(str: string, output: Uint8Array, outputOffset: number): void {\n  sharedTextEncoder!.encodeInto(str, output.subarray(outputOffset));\n}\n\nexport const utf8EncodeTE = sharedTextEncoder?.encodeInto ? utf8EncodeTEencodeInto : utf8EncodeTEencode;\n\nconst CHUNK_SIZE = 0x1_000;\n\nexport function utf8DecodeJs(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  let offset = inputOffset;\n  const end = offset + byteLength;\n\n  const units: Array<number> = [];\n  let result = \"\";\n  while (offset < end) {\n    const byte1 = bytes[offset++]!;\n    if ((byte1 & 0x80) === 0) {\n      // 1 byte\n      units.push(byte1);\n    } else if ((byte1 & 0xe0) === 0xc0) {\n      // 2 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      units.push(((byte1 & 0x1f) << 6) | byte2);\n    } else if ((byte1 & 0xf0) === 0xe0) {\n      // 3 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      const byte3 = bytes[offset++]! & 0x3f;\n      units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n    } else if ((byte1 & 0xf8) === 0xf0) {\n      // 4 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      const byte3 = bytes[offset++]! & 0x3f;\n      const byte4 = bytes[offset++]! & 0x3f;\n      let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n      if (unit > 0xffff) {\n        unit -= 0x10000;\n        units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n        unit = 0xdc00 | (unit & 0x3ff);\n      }\n      units.push(unit);\n    } else {\n      units.push(byte1);\n    }\n\n    if (units.length >= CHUNK_SIZE) {\n      result += String.fromCharCode(...units);\n      units.length = 0;\n    }\n  }\n\n  if (units.length > 0) {\n    result += String.fromCharCode(...units);\n  }\n\n  return result;\n}\n\nconst sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;\nexport const TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE\n  ? UINT32_MAX\n  : typeof process !== \"undefined\" && process?.env?.[\"TEXT_DECODER\"] !== \"force\"\n  ? 200\n  : 0;\n\nexport function utf8DecodeTD(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n  return sharedTextDecoder!.decode(stringBytes);\n}\n","\"use strict\";","export function ensureUint8Array(buffer) {\n    if (buffer instanceof Uint8Array) {\n        return buffer;\n    }\n    else if (ArrayBuffer.isView(buffer)) {\n        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    }\n    else if (buffer instanceof ArrayBuffer) {\n        return new Uint8Array(buffer);\n    }\n    else {\n        // ArrayLike<number>\n        return Uint8Array.from(buffer);\n    }\n}\nexport function createDataView(buffer) {\n    if (buffer instanceof ArrayBuffer) {\n        return new DataView(buffer);\n    }\n    var bufferView = ensureUint8Array(buffer);\n    return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n}\n//# sourceMappingURL=typedArrays.mjs.map","export function ensureUint8Array(buffer: ArrayLike<number> | Uint8Array | ArrayBufferView | ArrayBuffer): Uint8Array {\n  if (buffer instanceof Uint8Array) {\n    return buffer;\n  } else if (ArrayBuffer.isView(buffer)) {\n    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  } else if (buffer instanceof ArrayBuffer) {\n    return new Uint8Array(buffer);\n  } else {\n    // ArrayLike<number>\n    return Uint8Array.from(buffer);\n  }\n}\n\nexport function createDataView(buffer: ArrayLike<number> | ArrayBufferView | ArrayBuffer): DataView {\n  if (buffer instanceof ArrayBuffer) {\n    return new DataView(buffer);\n  }\n\n  const bufferView = ensureUint8Array(buffer);\n  return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n}\n","import { utf8DecodeJs } from \"./utils/utf8.mjs\";\nvar DEFAULT_MAX_KEY_LENGTH = 16;\nvar DEFAULT_MAX_LENGTH_PER_KEY = 16;\nvar CachedKeyDecoder = /** @class */ (function () {\n    function CachedKeyDecoder(maxKeyLength, maxLengthPerKey) {\n        if (maxKeyLength === void 0) { maxKeyLength = DEFAULT_MAX_KEY_LENGTH; }\n        if (maxLengthPerKey === void 0) { maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY; }\n        this.maxKeyLength = maxKeyLength;\n        this.maxLengthPerKey = maxLengthPerKey;\n        this.hit = 0;\n        this.miss = 0;\n        // avoid `new Array(N)`, which makes a sparse array,\n        // because a sparse array is typically slower than a non-sparse array.\n        this.caches = [];\n        for (var i = 0; i < this.maxKeyLength; i++) {\n            this.caches.push([]);\n        }\n    }\n    CachedKeyDecoder.prototype.canBeCached = function (byteLength) {\n        return byteLength > 0 && byteLength <= this.maxKeyLength;\n    };\n    CachedKeyDecoder.prototype.find = function (bytes, inputOffset, byteLength) {\n        var records = this.caches[byteLength - 1];\n        FIND_CHUNK: for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n            var record = records_1[_i];\n            var recordBytes = record.bytes;\n            for (var j = 0; j < byteLength; j++) {\n                if (recordBytes[j] !== bytes[inputOffset + j]) {\n                    continue FIND_CHUNK;\n                }\n            }\n            return record.str;\n        }\n        return null;\n    };\n    CachedKeyDecoder.prototype.store = function (bytes, value) {\n        var records = this.caches[bytes.length - 1];\n        var record = { bytes: bytes, str: value };\n        if (records.length >= this.maxLengthPerKey) {\n            // `records` are full!\n            // Set `record` to an arbitrary position.\n            records[(Math.random() * records.length) | 0] = record;\n        }\n        else {\n            records.push(record);\n        }\n    };\n    CachedKeyDecoder.prototype.decode = function (bytes, inputOffset, byteLength) {\n        var cachedValue = this.find(bytes, inputOffset, byteLength);\n        if (cachedValue != null) {\n            this.hit++;\n            return cachedValue;\n        }\n        this.miss++;\n        var str = utf8DecodeJs(bytes, inputOffset, byteLength);\n        // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n        var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n        this.store(slicedCopyOfBytes, str);\n        return str;\n    };\n    return CachedKeyDecoder;\n}());\nexport { CachedKeyDecoder };\n//# sourceMappingURL=CachedKeyDecoder.mjs.map","import { utf8DecodeJs } from \"./utils/utf8\";\n\nconst DEFAULT_MAX_KEY_LENGTH = 16;\nconst DEFAULT_MAX_LENGTH_PER_KEY = 16;\n\nexport interface KeyDecoder {\n  canBeCached(byteLength: number): boolean;\n  decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string;\n}\ninterface KeyCacheRecord {\n  readonly bytes: Uint8Array;\n  readonly str: string;\n}\n\nexport class CachedKeyDecoder implements KeyDecoder {\n  hit = 0;\n  miss = 0;\n  private readonly caches: Array<Array<KeyCacheRecord>>;\n\n  constructor(readonly maxKeyLength = DEFAULT_MAX_KEY_LENGTH, readonly maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {\n    // avoid `new Array(N)`, which makes a sparse array,\n    // because a sparse array is typically slower than a non-sparse array.\n    this.caches = [];\n    for (let i = 0; i < this.maxKeyLength; i++) {\n      this.caches.push([]);\n    }\n  }\n\n  public canBeCached(byteLength: number): boolean {\n    return byteLength > 0 && byteLength <= this.maxKeyLength;\n  }\n\n  private find(bytes: Uint8Array, inputOffset: number, byteLength: number): string | null {\n    const records = this.caches[byteLength - 1]!;\n\n    FIND_CHUNK: for (const record of records) {\n      const recordBytes = record.bytes;\n\n      for (let j = 0; j < byteLength; j++) {\n        if (recordBytes[j] !== bytes[inputOffset + j]) {\n          continue FIND_CHUNK;\n        }\n      }\n      return record.str;\n    }\n    return null;\n  }\n\n  private store(bytes: Uint8Array, value: string) {\n    const records = this.caches[bytes.length - 1]!;\n    const record: KeyCacheRecord = { bytes, str: value };\n\n    if (records.length >= this.maxLengthPerKey) {\n      // `records` are full!\n      // Set `record` to an arbitrary position.\n      records[(Math.random() * records.length) | 0] = record;\n    } else {\n      records.push(record);\n    }\n  }\n\n  public decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n    const cachedValue = this.find(bytes, inputOffset, byteLength);\n    if (cachedValue != null) {\n      this.hit++;\n      return cachedValue;\n    }\n    this.miss++;\n\n    const str = utf8DecodeJs(bytes, inputOffset, byteLength);\n    // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n    const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n    this.store(slicedCopyOfBytes, str);\n    return str;\n  }\n}\n","// utility for whatwg streams\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nexport function isAsyncIterable(object) {\n    return object[Symbol.asyncIterator] != null;\n}\nfunction assertNonNull(value) {\n    if (value == null) {\n        throw new Error(\"Assertion Failure: value must not be null nor undefined\");\n    }\n}\nexport function asyncIterableFromStream(stream) {\n    return __asyncGenerator(this, arguments, function asyncIterableFromStream_1() {\n        var reader, _a, done, value;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    reader = stream.getReader();\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, , 9, 10]);\n                    _b.label = 2;\n                case 2:\n                    if (!true) return [3 /*break*/, 8];\n                    return [4 /*yield*/, __await(reader.read())];\n                case 3:\n                    _a = _b.sent(), done = _a.done, value = _a.value;\n                    if (!done) return [3 /*break*/, 5];\n                    return [4 /*yield*/, __await(void 0)];\n                case 4: return [2 /*return*/, _b.sent()];\n                case 5:\n                    assertNonNull(value);\n                    return [4 /*yield*/, __await(value)];\n                case 6: return [4 /*yield*/, _b.sent()];\n                case 7:\n                    _b.sent();\n                    return [3 /*break*/, 2];\n                case 8: return [3 /*break*/, 10];\n                case 9:\n                    reader.releaseLock();\n                    return [7 /*endfinally*/];\n                case 10: return [2 /*return*/];\n            }\n        });\n    });\n}\nexport function ensureAsyncIterable(streamLike) {\n    if (isAsyncIterable(streamLike)) {\n        return streamLike;\n    }\n    else {\n        return asyncIterableFromStream(streamLike);\n    }\n}\n//# sourceMappingURL=stream.mjs.map","// utility for whatwg streams\n\n// The living standard of whatwg streams says\n// ReadableStream is also AsyncIterable, but\n// as of June 2019, no browser implements it.\n// See https://streams.spec.whatwg.org/ for details\nexport type ReadableStreamLike<T> = AsyncIterable<T> | ReadableStream<T>;\n\nexport function isAsyncIterable<T>(object: ReadableStreamLike<T>): object is AsyncIterable<T> {\n  return (object as any)[Symbol.asyncIterator] != null;\n}\n\nfunction assertNonNull<T>(value: T | null | undefined): asserts value is T {\n  if (value == null) {\n    throw new Error(\"Assertion Failure: value must not be null nor undefined\");\n  }\n}\n\nexport async function* asyncIterableFromStream<T>(stream: ReadableStream<T>): AsyncIterable<T> {\n  const reader = stream.getReader();\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        return;\n      }\n      assertNonNull(value);\n      yield value;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nexport function ensureAsyncIterable<T>(streamLike: ReadableStreamLike<T>): AsyncIterable<T> {\n  if (isAsyncIterable(streamLike)) {\n    return streamLike;\n  } else {\n    return asyncIterableFromStream(streamLike);\n  }\n}\n","import { Decoder } from \"./Decoder.mjs\";\nexport var defaultDecodeOptions = {};\n/**\n * It decodes a single MessagePack object in a buffer.\n *\n * This is a synchronous decoding function.\n * See other variants for asynchronous decoding: {@link decodeAsync()}, {@link decodeStream()}, or {@link decodeArrayStream()}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decode(buffer, options) {\n    if (options === void 0) { options = defaultDecodeOptions; }\n    var decoder = new Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decode(buffer);\n}\n/**\n * It decodes multiple MessagePack objects in a buffer.\n * This is corresponding to {@link decodeMultiStream()}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeMulti(buffer, options) {\n    if (options === void 0) { options = defaultDecodeOptions; }\n    var decoder = new Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decodeMulti(buffer);\n}\n//# sourceMappingURL=decode.mjs.map","import { Decoder } from \"./Decoder\";\nimport type { ExtensionCodecType } from \"./ExtensionCodec\";\nimport type { ContextOf, SplitUndefined } from \"./context\";\n\nexport type DecodeOptions<ContextType = undefined> = Readonly<\n  Partial<{\n    extensionCodec: ExtensionCodecType<ContextType>;\n\n    /**\n     * Maximum string length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxStrLength: number;\n    /**\n     * Maximum binary length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxBinLength: number;\n    /**\n     * Maximum array length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxArrayLength: number;\n    /**\n     * Maximum map length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxMapLength: number;\n    /**\n     * Maximum extension length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxExtLength: number;\n  }>\n> &\n  ContextOf<ContextType>;\n\nexport const defaultDecodeOptions: DecodeOptions = {};\n\n/**\n * It decodes a single MessagePack object in a buffer.\n *\n * This is a synchronous decoding function.\n * See other variants for asynchronous decoding: {@link decodeAsync()}, {@link decodeStream()}, or {@link decodeArrayStream()}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decode<ContextType = undefined>(\n  buffer: ArrayLike<number> | BufferSource,\n  options: DecodeOptions<SplitUndefined<ContextType>> = defaultDecodeOptions as any,\n): unknown {\n  const decoder = new Decoder(\n    options.extensionCodec,\n    (options as typeof options & { context: any }).context,\n    options.maxStrLength,\n    options.maxBinLength,\n    options.maxArrayLength,\n    options.maxMapLength,\n    options.maxExtLength,\n  );\n  return decoder.decode(buffer);\n}\n\n/**\n * It decodes multiple MessagePack objects in a buffer.\n * This is corresponding to {@link decodeMultiStream()}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeMulti<ContextType = undefined>(\n  buffer: ArrayLike<number> | BufferSource,\n  options: DecodeOptions<SplitUndefined<ContextType>> = defaultDecodeOptions as any,\n): Generator<unknown, void, unknown> {\n  const decoder = new Decoder(\n    options.extensionCodec,\n    (options as typeof options & { context: any }).context,\n    options.maxStrLength,\n    options.maxBinLength,\n    options.maxArrayLength,\n    options.maxMapLength,\n    options.maxExtLength,\n  );\n  return decoder.decodeMulti(buffer);\n}\n","import { utf8EncodeJs, utf8Count, TEXT_ENCODER_THRESHOLD, utf8EncodeTE } from \"./utils/utf8.mjs\";\nimport { ExtensionCodec } from \"./ExtensionCodec.mjs\";\nimport { setInt64, setUint64 } from \"./utils/int.mjs\";\nimport { ensureUint8Array } from \"./utils/typedArrays.mjs\";\nexport var DEFAULT_MAX_DEPTH = 100;\nexport var DEFAULT_INITIAL_BUFFER_SIZE = 2048;\nvar Encoder = /** @class */ (function () {\n    function Encoder(extensionCodec, context, maxDepth, initialBufferSize, sortKeys, forceFloat32, ignoreUndefined, forceIntegerToFloat) {\n        if (extensionCodec === void 0) { extensionCodec = ExtensionCodec.defaultCodec; }\n        if (context === void 0) { context = undefined; }\n        if (maxDepth === void 0) { maxDepth = DEFAULT_MAX_DEPTH; }\n        if (initialBufferSize === void 0) { initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE; }\n        if (sortKeys === void 0) { sortKeys = false; }\n        if (forceFloat32 === void 0) { forceFloat32 = false; }\n        if (ignoreUndefined === void 0) { ignoreUndefined = false; }\n        if (forceIntegerToFloat === void 0) { forceIntegerToFloat = false; }\n        this.extensionCodec = extensionCodec;\n        this.context = context;\n        this.maxDepth = maxDepth;\n        this.initialBufferSize = initialBufferSize;\n        this.sortKeys = sortKeys;\n        this.forceFloat32 = forceFloat32;\n        this.ignoreUndefined = ignoreUndefined;\n        this.forceIntegerToFloat = forceIntegerToFloat;\n        this.pos = 0;\n        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n        this.bytes = new Uint8Array(this.view.buffer);\n    }\n    Encoder.prototype.reinitializeState = function () {\n        this.pos = 0;\n    };\n    /**\n     * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.\n     *\n     * @returns Encodes the object and returns a shared reference the encoder's internal buffer.\n     */\n    Encoder.prototype.encodeSharedRef = function (object) {\n        this.reinitializeState();\n        this.doEncode(object, 1);\n        return this.bytes.subarray(0, this.pos);\n    };\n    /**\n     * @returns Encodes the object and returns a copy of the encoder's internal buffer.\n     */\n    Encoder.prototype.encode = function (object) {\n        this.reinitializeState();\n        this.doEncode(object, 1);\n        return this.bytes.slice(0, this.pos);\n    };\n    Encoder.prototype.doEncode = function (object, depth) {\n        if (depth > this.maxDepth) {\n            throw new Error(\"Too deep objects in depth \".concat(depth));\n        }\n        if (object == null) {\n            this.encodeNil();\n        }\n        else if (typeof object === \"boolean\") {\n            this.encodeBoolean(object);\n        }\n        else if (typeof object === \"number\") {\n            this.encodeNumber(object);\n        }\n        else if (typeof object === \"string\") {\n            this.encodeString(object);\n        }\n        else {\n            this.encodeObject(object, depth);\n        }\n    };\n    Encoder.prototype.ensureBufferSizeToWrite = function (sizeToWrite) {\n        var requiredSize = this.pos + sizeToWrite;\n        if (this.view.byteLength < requiredSize) {\n            this.resizeBuffer(requiredSize * 2);\n        }\n    };\n    Encoder.prototype.resizeBuffer = function (newSize) {\n        var newBuffer = new ArrayBuffer(newSize);\n        var newBytes = new Uint8Array(newBuffer);\n        var newView = new DataView(newBuffer);\n        newBytes.set(this.bytes);\n        this.view = newView;\n        this.bytes = newBytes;\n    };\n    Encoder.prototype.encodeNil = function () {\n        this.writeU8(0xc0);\n    };\n    Encoder.prototype.encodeBoolean = function (object) {\n        if (object === false) {\n            this.writeU8(0xc2);\n        }\n        else {\n            this.writeU8(0xc3);\n        }\n    };\n    Encoder.prototype.encodeNumber = function (object) {\n        if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {\n            if (object >= 0) {\n                if (object < 0x80) {\n                    // positive fixint\n                    this.writeU8(object);\n                }\n                else if (object < 0x100) {\n                    // uint 8\n                    this.writeU8(0xcc);\n                    this.writeU8(object);\n                }\n                else if (object < 0x10000) {\n                    // uint 16\n                    this.writeU8(0xcd);\n                    this.writeU16(object);\n                }\n                else if (object < 0x100000000) {\n                    // uint 32\n                    this.writeU8(0xce);\n                    this.writeU32(object);\n                }\n                else {\n                    // uint 64\n                    this.writeU8(0xcf);\n                    this.writeU64(object);\n                }\n            }\n            else {\n                if (object >= -0x20) {\n                    // negative fixint\n                    this.writeU8(0xe0 | (object + 0x20));\n                }\n                else if (object >= -0x80) {\n                    // int 8\n                    this.writeU8(0xd0);\n                    this.writeI8(object);\n                }\n                else if (object >= -0x8000) {\n                    // int 16\n                    this.writeU8(0xd1);\n                    this.writeI16(object);\n                }\n                else if (object >= -0x80000000) {\n                    // int 32\n                    this.writeU8(0xd2);\n                    this.writeI32(object);\n                }\n                else {\n                    // int 64\n                    this.writeU8(0xd3);\n                    this.writeI64(object);\n                }\n            }\n        }\n        else {\n            // non-integer numbers\n            if (this.forceFloat32) {\n                // float 32\n                this.writeU8(0xca);\n                this.writeF32(object);\n            }\n            else {\n                // float 64\n                this.writeU8(0xcb);\n                this.writeF64(object);\n            }\n        }\n    };\n    Encoder.prototype.writeStringHeader = function (byteLength) {\n        if (byteLength < 32) {\n            // fixstr\n            this.writeU8(0xa0 + byteLength);\n        }\n        else if (byteLength < 0x100) {\n            // str 8\n            this.writeU8(0xd9);\n            this.writeU8(byteLength);\n        }\n        else if (byteLength < 0x10000) {\n            // str 16\n            this.writeU8(0xda);\n            this.writeU16(byteLength);\n        }\n        else if (byteLength < 0x100000000) {\n            // str 32\n            this.writeU8(0xdb);\n            this.writeU32(byteLength);\n        }\n        else {\n            throw new Error(\"Too long string: \".concat(byteLength, \" bytes in UTF-8\"));\n        }\n    };\n    Encoder.prototype.encodeString = function (object) {\n        var maxHeaderSize = 1 + 4;\n        var strLength = object.length;\n        if (strLength > TEXT_ENCODER_THRESHOLD) {\n            var byteLength = utf8Count(object);\n            this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n            this.writeStringHeader(byteLength);\n            utf8EncodeTE(object, this.bytes, this.pos);\n            this.pos += byteLength;\n        }\n        else {\n            var byteLength = utf8Count(object);\n            this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n            this.writeStringHeader(byteLength);\n            utf8EncodeJs(object, this.bytes, this.pos);\n            this.pos += byteLength;\n        }\n    };\n    Encoder.prototype.encodeObject = function (object, depth) {\n        // try to encode objects with custom codec first of non-primitives\n        var ext = this.extensionCodec.tryToEncode(object, this.context);\n        if (ext != null) {\n            this.encodeExtension(ext);\n        }\n        else if (Array.isArray(object)) {\n            this.encodeArray(object, depth);\n        }\n        else if (ArrayBuffer.isView(object)) {\n            this.encodeBinary(object);\n        }\n        else if (typeof object === \"object\") {\n            this.encodeMap(object, depth);\n        }\n        else {\n            // symbol, function and other special object come here unless extensionCodec handles them.\n            throw new Error(\"Unrecognized object: \".concat(Object.prototype.toString.apply(object)));\n        }\n    };\n    Encoder.prototype.encodeBinary = function (object) {\n        var size = object.byteLength;\n        if (size < 0x100) {\n            // bin 8\n            this.writeU8(0xc4);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // bin 16\n            this.writeU8(0xc5);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // bin 32\n            this.writeU8(0xc6);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large binary: \".concat(size));\n        }\n        var bytes = ensureUint8Array(object);\n        this.writeU8a(bytes);\n    };\n    Encoder.prototype.encodeArray = function (object, depth) {\n        var size = object.length;\n        if (size < 16) {\n            // fixarray\n            this.writeU8(0x90 + size);\n        }\n        else if (size < 0x10000) {\n            // array 16\n            this.writeU8(0xdc);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // array 32\n            this.writeU8(0xdd);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large array: \".concat(size));\n        }\n        for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {\n            var item = object_1[_i];\n            this.doEncode(item, depth + 1);\n        }\n    };\n    Encoder.prototype.countWithoutUndefined = function (object, keys) {\n        var count = 0;\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var key = keys_1[_i];\n            if (object[key] !== undefined) {\n                count++;\n            }\n        }\n        return count;\n    };\n    Encoder.prototype.encodeMap = function (object, depth) {\n        var keys = Object.keys(object);\n        if (this.sortKeys) {\n            keys.sort();\n        }\n        var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n        if (size < 16) {\n            // fixmap\n            this.writeU8(0x80 + size);\n        }\n        else if (size < 0x10000) {\n            // map 16\n            this.writeU8(0xde);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // map 32\n            this.writeU8(0xdf);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large map object: \".concat(size));\n        }\n        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n            var key = keys_2[_i];\n            var value = object[key];\n            if (!(this.ignoreUndefined && value === undefined)) {\n                this.encodeString(key);\n                this.doEncode(value, depth + 1);\n            }\n        }\n    };\n    Encoder.prototype.encodeExtension = function (ext) {\n        var size = ext.data.length;\n        if (size === 1) {\n            // fixext 1\n            this.writeU8(0xd4);\n        }\n        else if (size === 2) {\n            // fixext 2\n            this.writeU8(0xd5);\n        }\n        else if (size === 4) {\n            // fixext 4\n            this.writeU8(0xd6);\n        }\n        else if (size === 8) {\n            // fixext 8\n            this.writeU8(0xd7);\n        }\n        else if (size === 16) {\n            // fixext 16\n            this.writeU8(0xd8);\n        }\n        else if (size < 0x100) {\n            // ext 8\n            this.writeU8(0xc7);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // ext 16\n            this.writeU8(0xc8);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // ext 32\n            this.writeU8(0xc9);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large extension object: \".concat(size));\n        }\n        this.writeI8(ext.type);\n        this.writeU8a(ext.data);\n    };\n    Encoder.prototype.writeU8 = function (value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setUint8(this.pos, value);\n        this.pos++;\n    };\n    Encoder.prototype.writeU8a = function (values) {\n        var size = values.length;\n        this.ensureBufferSizeToWrite(size);\n        this.bytes.set(values, this.pos);\n        this.pos += size;\n    };\n    Encoder.prototype.writeI8 = function (value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setInt8(this.pos, value);\n        this.pos++;\n    };\n    Encoder.prototype.writeU16 = function (value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setUint16(this.pos, value);\n        this.pos += 2;\n    };\n    Encoder.prototype.writeI16 = function (value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setInt16(this.pos, value);\n        this.pos += 2;\n    };\n    Encoder.prototype.writeU32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setUint32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeI32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setInt32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeF32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setFloat32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeF64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setFloat64(this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeU64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        setUint64(this.view, this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeI64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        setInt64(this.view, this.pos, value);\n        this.pos += 8;\n    };\n    return Encoder;\n}());\nexport { Encoder };\n//# sourceMappingURL=Encoder.mjs.map","import { utf8EncodeJs, utf8Count, TEXT_ENCODER_THRESHOLD, utf8EncodeTE } from \"./utils/utf8\";\nimport { ExtensionCodec, ExtensionCodecType } from \"./ExtensionCodec\";\nimport { setInt64, setUint64 } from \"./utils/int\";\nimport { ensureUint8Array } from \"./utils/typedArrays\";\nimport type { ExtData } from \"./ExtData\";\n\nexport const DEFAULT_MAX_DEPTH = 100;\nexport const DEFAULT_INITIAL_BUFFER_SIZE = 2048;\n\nexport class Encoder<ContextType = undefined> {\n  private pos = 0;\n  private view = new DataView(new ArrayBuffer(this.initialBufferSize));\n  private bytes = new Uint8Array(this.view.buffer);\n\n  public constructor(\n    private readonly extensionCodec: ExtensionCodecType<ContextType> = ExtensionCodec.defaultCodec as any,\n    private readonly context: ContextType = undefined as any,\n    private readonly maxDepth = DEFAULT_MAX_DEPTH,\n    private readonly initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE,\n    private readonly sortKeys = false,\n    private readonly forceFloat32 = false,\n    private readonly ignoreUndefined = false,\n    private readonly forceIntegerToFloat = false,\n  ) {}\n\n  private reinitializeState() {\n    this.pos = 0;\n  }\n\n  /**\n   * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.\n   *\n   * @returns Encodes the object and returns a shared reference the encoder's internal buffer.\n   */\n  public encodeSharedRef(object: unknown): Uint8Array {\n    this.reinitializeState();\n    this.doEncode(object, 1);\n    return this.bytes.subarray(0, this.pos);\n  }\n\n  /**\n   * @returns Encodes the object and returns a copy of the encoder's internal buffer.\n   */\n  public encode(object: unknown): Uint8Array {\n    this.reinitializeState();\n    this.doEncode(object, 1);\n    return this.bytes.slice(0, this.pos);\n  }\n\n  private doEncode(object: unknown, depth: number): void {\n    if (depth > this.maxDepth) {\n      throw new Error(`Too deep objects in depth ${depth}`);\n    }\n\n    if (object == null) {\n      this.encodeNil();\n    } else if (typeof object === \"boolean\") {\n      this.encodeBoolean(object);\n    } else if (typeof object === \"number\") {\n      this.encodeNumber(object);\n    } else if (typeof object === \"string\") {\n      this.encodeString(object);\n    } else {\n      this.encodeObject(object, depth);\n    }\n  }\n\n  private ensureBufferSizeToWrite(sizeToWrite: number) {\n    const requiredSize = this.pos + sizeToWrite;\n\n    if (this.view.byteLength < requiredSize) {\n      this.resizeBuffer(requiredSize * 2);\n    }\n  }\n\n  private resizeBuffer(newSize: number) {\n    const newBuffer = new ArrayBuffer(newSize);\n    const newBytes = new Uint8Array(newBuffer);\n    const newView = new DataView(newBuffer);\n\n    newBytes.set(this.bytes);\n\n    this.view = newView;\n    this.bytes = newBytes;\n  }\n\n  private encodeNil() {\n    this.writeU8(0xc0);\n  }\n\n  private encodeBoolean(object: boolean) {\n    if (object === false) {\n      this.writeU8(0xc2);\n    } else {\n      this.writeU8(0xc3);\n    }\n  }\n  private encodeNumber(object: number) {\n    if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {\n      if (object >= 0) {\n        if (object < 0x80) {\n          // positive fixint\n          this.writeU8(object);\n        } else if (object < 0x100) {\n          // uint 8\n          this.writeU8(0xcc);\n          this.writeU8(object);\n        } else if (object < 0x10000) {\n          // uint 16\n          this.writeU8(0xcd);\n          this.writeU16(object);\n        } else if (object < 0x100000000) {\n          // uint 32\n          this.writeU8(0xce);\n          this.writeU32(object);\n        } else {\n          // uint 64\n          this.writeU8(0xcf);\n          this.writeU64(object);\n        }\n      } else {\n        if (object >= -0x20) {\n          // negative fixint\n          this.writeU8(0xe0 | (object + 0x20));\n        } else if (object >= -0x80) {\n          // int 8\n          this.writeU8(0xd0);\n          this.writeI8(object);\n        } else if (object >= -0x8000) {\n          // int 16\n          this.writeU8(0xd1);\n          this.writeI16(object);\n        } else if (object >= -0x80000000) {\n          // int 32\n          this.writeU8(0xd2);\n          this.writeI32(object);\n        } else {\n          // int 64\n          this.writeU8(0xd3);\n          this.writeI64(object);\n        }\n      }\n    } else {\n      // non-integer numbers\n      if (this.forceFloat32) {\n        // float 32\n        this.writeU8(0xca);\n        this.writeF32(object);\n      } else {\n        // float 64\n        this.writeU8(0xcb);\n        this.writeF64(object);\n      }\n    }\n  }\n\n  private writeStringHeader(byteLength: number) {\n    if (byteLength < 32) {\n      // fixstr\n      this.writeU8(0xa0 + byteLength);\n    } else if (byteLength < 0x100) {\n      // str 8\n      this.writeU8(0xd9);\n      this.writeU8(byteLength);\n    } else if (byteLength < 0x10000) {\n      // str 16\n      this.writeU8(0xda);\n      this.writeU16(byteLength);\n    } else if (byteLength < 0x100000000) {\n      // str 32\n      this.writeU8(0xdb);\n      this.writeU32(byteLength);\n    } else {\n      throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);\n    }\n  }\n\n  private encodeString(object: string) {\n    const maxHeaderSize = 1 + 4;\n    const strLength = object.length;\n\n    if (strLength > TEXT_ENCODER_THRESHOLD) {\n      const byteLength = utf8Count(object);\n      this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n      this.writeStringHeader(byteLength);\n      utf8EncodeTE(object, this.bytes, this.pos);\n      this.pos += byteLength;\n    } else {\n      const byteLength = utf8Count(object);\n      this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n      this.writeStringHeader(byteLength);\n      utf8EncodeJs(object, this.bytes, this.pos);\n      this.pos += byteLength;\n    }\n  }\n\n  private encodeObject(object: unknown, depth: number) {\n    // try to encode objects with custom codec first of non-primitives\n    const ext = this.extensionCodec.tryToEncode(object, this.context);\n    if (ext != null) {\n      this.encodeExtension(ext);\n    } else if (Array.isArray(object)) {\n      this.encodeArray(object, depth);\n    } else if (ArrayBuffer.isView(object)) {\n      this.encodeBinary(object);\n    } else if (typeof object === \"object\") {\n      this.encodeMap(object as Record<string, unknown>, depth);\n    } else {\n      // symbol, function and other special object come here unless extensionCodec handles them.\n      throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);\n    }\n  }\n\n  private encodeBinary(object: ArrayBufferView) {\n    const size = object.byteLength;\n    if (size < 0x100) {\n      // bin 8\n      this.writeU8(0xc4);\n      this.writeU8(size);\n    } else if (size < 0x10000) {\n      // bin 16\n      this.writeU8(0xc5);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // bin 32\n      this.writeU8(0xc6);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large binary: ${size}`);\n    }\n    const bytes = ensureUint8Array(object);\n    this.writeU8a(bytes);\n  }\n\n  private encodeArray(object: Array<unknown>, depth: number) {\n    const size = object.length;\n    if (size < 16) {\n      // fixarray\n      this.writeU8(0x90 + size);\n    } else if (size < 0x10000) {\n      // array 16\n      this.writeU8(0xdc);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // array 32\n      this.writeU8(0xdd);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large array: ${size}`);\n    }\n    for (const item of object) {\n      this.doEncode(item, depth + 1);\n    }\n  }\n\n  private countWithoutUndefined(object: Record<string, unknown>, keys: ReadonlyArray<string>): number {\n    let count = 0;\n\n    for (const key of keys) {\n      if (object[key] !== undefined) {\n        count++;\n      }\n    }\n\n    return count;\n  }\n\n  private encodeMap(object: Record<string, unknown>, depth: number) {\n    const keys = Object.keys(object);\n    if (this.sortKeys) {\n      keys.sort();\n    }\n\n    const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n\n    if (size < 16) {\n      // fixmap\n      this.writeU8(0x80 + size);\n    } else if (size < 0x10000) {\n      // map 16\n      this.writeU8(0xde);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // map 32\n      this.writeU8(0xdf);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large map object: ${size}`);\n    }\n\n    for (const key of keys) {\n      const value = object[key];\n\n      if (!(this.ignoreUndefined && value === undefined)) {\n        this.encodeString(key);\n        this.doEncode(value, depth + 1);\n      }\n    }\n  }\n\n  private encodeExtension(ext: ExtData) {\n    const size = ext.data.length;\n    if (size === 1) {\n      // fixext 1\n      this.writeU8(0xd4);\n    } else if (size === 2) {\n      // fixext 2\n      this.writeU8(0xd5);\n    } else if (size === 4) {\n      // fixext 4\n      this.writeU8(0xd6);\n    } else if (size === 8) {\n      // fixext 8\n      this.writeU8(0xd7);\n    } else if (size === 16) {\n      // fixext 16\n      this.writeU8(0xd8);\n    } else if (size < 0x100) {\n      // ext 8\n      this.writeU8(0xc7);\n      this.writeU8(size);\n    } else if (size < 0x10000) {\n      // ext 16\n      this.writeU8(0xc8);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // ext 32\n      this.writeU8(0xc9);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large extension object: ${size}`);\n    }\n    this.writeI8(ext.type);\n    this.writeU8a(ext.data);\n  }\n\n  private writeU8(value: number) {\n    this.ensureBufferSizeToWrite(1);\n\n    this.view.setUint8(this.pos, value);\n    this.pos++;\n  }\n\n  private writeU8a(values: ArrayLike<number>) {\n    const size = values.length;\n    this.ensureBufferSizeToWrite(size);\n\n    this.bytes.set(values, this.pos);\n    this.pos += size;\n  }\n\n  private writeI8(value: number) {\n    this.ensureBufferSizeToWrite(1);\n\n    this.view.setInt8(this.pos, value);\n    this.pos++;\n  }\n\n  private writeU16(value: number) {\n    this.ensureBufferSizeToWrite(2);\n\n    this.view.setUint16(this.pos, value);\n    this.pos += 2;\n  }\n\n  private writeI16(value: number) {\n    this.ensureBufferSizeToWrite(2);\n\n    this.view.setInt16(this.pos, value);\n    this.pos += 2;\n  }\n\n  private writeU32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setUint32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeI32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setInt32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeF32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n    this.view.setFloat32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeF64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n    this.view.setFloat64(this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeU64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    setUint64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeI64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    setInt64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n}\n","import logger from \"../../logger.js\";\nimport type { Peer } from \"../../peer.js\";\nimport { DataConnection } from \"../DataConnection.js\";\n\nexport abstract class StreamConnection extends DataConnection {\n\tprivate _CHUNK_SIZE = 1024 * 8 * 4;\n\tprivate _splitStream = new TransformStream<Uint8Array>({\n\t\ttransform: (chunk, controller) => {\n\t\t\tfor (let split = 0; split < chunk.length; split += this._CHUNK_SIZE) {\n\t\t\t\tcontroller.enqueue(chunk.subarray(split, split + this._CHUNK_SIZE));\n\t\t\t}\n\t\t},\n\t});\n\tprivate _rawSendStream = new WritableStream<ArrayBuffer>({\n\t\twrite: async (chunk, controller) => {\n\t\t\tconst openEvent = new Promise((resolve) =>\n\t\t\t\tthis.dataChannel.addEventListener(\"bufferedamountlow\", resolve, {\n\t\t\t\t\tonce: true,\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\t// if we can send the chunk now, send it\n\t\t\t// if not, we wait until at least half of the sending buffer is free again\n\t\t\tawait (this.dataChannel.bufferedAmount <=\n\t\t\t\tDataConnection.MAX_BUFFERED_AMOUNT - chunk.byteLength || openEvent);\n\n\t\t\t// TODO: what can go wrong here?\n\t\t\ttry {\n\t\t\t\tthis.dataChannel.send(chunk);\n\t\t\t} catch (e) {\n\t\t\t\tlogger.error(`DC#:${this.connectionId} Error when sending:`, e);\n\t\t\t\tcontroller.error(e);\n\t\t\t\tthis.close();\n\t\t\t}\n\t\t},\n\t});\n\tprotected writer = this._splitStream.writable.getWriter();\n\n\tprotected _rawReadStream = new ReadableStream<ArrayBuffer>({\n\t\tstart: (controller) => {\n\t\t\tthis.once(\"open\", () => {\n\t\t\t\tthis.dataChannel.addEventListener(\"message\", (e) => {\n\t\t\t\t\tcontroller.enqueue(e.data);\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\t});\n\n\tprotected constructor(peerId: string, provider: Peer, options: any) {\n\t\tsuper(peerId, provider, { ...options, reliable: true });\n\n\t\tvoid this._splitStream.readable.pipeTo(this._rawSendStream);\n\t}\n\n\tpublic override _initializeDataChannel(dc) {\n\t\tsuper._initializeDataChannel(dc);\n\t\tthis.dataChannel.binaryType = \"arraybuffer\";\n\t\tthis.dataChannel.bufferedAmountLowThreshold =\n\t\t\tDataConnection.MAX_BUFFERED_AMOUNT / 2;\n\t}\n}\n","const LOG_PREFIX = \"PeerJS: \";\n\n/*\nPrints log messages depending on the debug level passed in. Defaults to 0.\n0  Prints no logs.\n1  Prints only errors.\n2  Prints errors and warnings.\n3  Prints all logs.\n*/\nexport enum LogLevel {\n\t/**\n\t * Prints no logs.\n\t */\n\tDisabled,\n\t/**\n\t * Prints only errors.\n\t */\n\tErrors,\n\t/**\n\t * Prints errors and warnings.\n\t */\n\tWarnings,\n\t/**\n\t * Prints all logs.\n\t */\n\tAll,\n}\n\nclass Logger {\n\tprivate _logLevel = LogLevel.Disabled;\n\n\tget logLevel(): LogLevel {\n\t\treturn this._logLevel;\n\t}\n\n\tset logLevel(logLevel: LogLevel) {\n\t\tthis._logLevel = logLevel;\n\t}\n\n\tlog(...args: any[]) {\n\t\tif (this._logLevel >= LogLevel.All) {\n\t\t\tthis._print(LogLevel.All, ...args);\n\t\t}\n\t}\n\n\twarn(...args: any[]) {\n\t\tif (this._logLevel >= LogLevel.Warnings) {\n\t\t\tthis._print(LogLevel.Warnings, ...args);\n\t\t}\n\t}\n\n\terror(...args: any[]) {\n\t\tif (this._logLevel >= LogLevel.Errors) {\n\t\t\tthis._print(LogLevel.Errors, ...args);\n\t\t}\n\t}\n\n\tsetLogFunction(fn: (logLevel: LogLevel, ..._: any[]) => void): void {\n\t\tthis._print = fn;\n\t}\n\n\tprivate _print(logLevel: LogLevel, ...rest: any[]): void {\n\t\tconst copy = [LOG_PREFIX, ...rest];\n\n\t\tfor (const i in copy) {\n\t\t\tif (copy[i] instanceof Error) {\n\t\t\t\tcopy[i] = \"(\" + copy[i].name + \") \" + copy[i].message;\n\t\t\t}\n\t\t}\n\n\t\tif (logLevel >= LogLevel.All) {\n\t\t\tconsole.log(...copy);\n\t\t} else if (logLevel >= LogLevel.Warnings) {\n\t\t\tconsole.warn(\"WARNING\", ...copy);\n\t\t} else if (logLevel >= LogLevel.Errors) {\n\t\t\tconsole.error(\"ERROR\", ...copy);\n\t\t}\n\t}\n}\n\nexport default new Logger();\n","import logger from \"../logger\";\nimport { Negotiator } from \"../negotiator\";\nimport {\n\tBaseConnectionErrorType,\n\tConnectionType,\n\tDataConnectionErrorType,\n\tServerMessageType,\n} from \"../enums\";\nimport type { Peer } from \"../peer\";\nimport { BaseConnection, type BaseConnectionEvents } from \"../baseconnection\";\nimport type { ServerMessage } from \"../servermessage\";\nimport type { EventsWithError } from \"../peerError\";\nimport { randomToken } from \"../utils/randomToken\";\n\nexport interface DataConnectionEvents\n\textends EventsWithError<DataConnectionErrorType | BaseConnectionErrorType>,\n\t\tBaseConnectionEvents<DataConnectionErrorType | BaseConnectionErrorType> {\n\t/**\n\t * Emitted when data is received from the remote peer.\n\t */\n\tdata: (data: unknown) => void;\n\t/**\n\t * Emitted when the connection is established and ready-to-use.\n\t */\n\topen: () => void;\n}\n\n/**\n * Wraps a DataChannel between two Peers.\n */\nexport abstract class DataConnection extends BaseConnection<\n\tDataConnectionEvents,\n\tDataConnectionErrorType\n> {\n\tprotected static readonly ID_PREFIX = \"dc_\";\n\tprotected static readonly MAX_BUFFERED_AMOUNT = 8 * 1024 * 1024;\n\n\tprivate _negotiator: Negotiator<DataConnectionEvents, this>;\n\tabstract readonly serialization: string;\n\treadonly reliable: boolean;\n\n\tpublic get type() {\n\t\treturn ConnectionType.Data;\n\t}\n\n\tconstructor(peerId: string, provider: Peer, options: any) {\n\t\tsuper(peerId, provider, options);\n\n\t\tthis.connectionId =\n\t\t\tthis.options.connectionId || DataConnection.ID_PREFIX + randomToken();\n\n\t\tthis.label = this.options.label || this.connectionId;\n\t\tthis.reliable = !!this.options.reliable;\n\n\t\tthis._negotiator = new Negotiator(this);\n\n\t\tthis._negotiator.startConnection(\n\t\t\tthis.options._payload || {\n\t\t\t\toriginator: true,\n\t\t\t\treliable: this.reliable,\n\t\t\t},\n\t\t);\n\t}\n\n\t/** Called by the Negotiator when the DataChannel is ready. */\n\toverride _initializeDataChannel(dc: RTCDataChannel): void {\n\t\tthis.dataChannel = dc;\n\n\t\tthis.dataChannel.onopen = () => {\n\t\t\tlogger.log(`DC#${this.connectionId} dc connection success`);\n\t\t\tthis._open = true;\n\t\t\tthis.emit(\"open\");\n\t\t};\n\n\t\tthis.dataChannel.onmessage = (e) => {\n\t\t\tlogger.log(`DC#${this.connectionId} dc onmessage:`, e.data);\n\t\t\t// this._handleDataMessage(e);\n\t\t};\n\n\t\tthis.dataChannel.onclose = () => {\n\t\t\tlogger.log(`DC#${this.connectionId} dc closed for:`, this.peer);\n\t\t\tthis.close();\n\t\t};\n\t}\n\n\t/**\n\t * Exposed functionality for users.\n\t */\n\n\t/** Allows user to close connection. */\n\tclose(options?: { flush?: boolean }): void {\n\t\tif (options?.flush) {\n\t\t\tthis.send({\n\t\t\t\t__peerData: {\n\t\t\t\t\ttype: \"close\",\n\t\t\t\t},\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tif (this._negotiator) {\n\t\t\tthis._negotiator.cleanup();\n\t\t\tthis._negotiator = null;\n\t\t}\n\n\t\tif (this.provider) {\n\t\t\tthis.provider._removeConnection(this);\n\n\t\t\tthis.provider = null;\n\t\t}\n\n\t\tif (this.dataChannel) {\n\t\t\tthis.dataChannel.onopen = null;\n\t\t\tthis.dataChannel.onmessage = null;\n\t\t\tthis.dataChannel.onclose = null;\n\t\t\tthis.dataChannel = null;\n\t\t}\n\n\t\tif (!this.open) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._open = false;\n\n\t\tsuper.emit(\"close\");\n\t}\n\n\tprotected abstract _send(data: any, chunked: boolean): void;\n\n\t/** Allows user to send data. */\n\tpublic send(data: any, chunked = false) {\n\t\tif (!this.open) {\n\t\t\tthis.emitError(\n\t\t\t\tDataConnectionErrorType.NotOpenYet,\n\t\t\t\t\"Connection is not open. You should listen for the `open` event before sending messages.\",\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\treturn this._send(data, chunked);\n\t}\n\n\tasync handleMessage(message: ServerMessage) {\n\t\tconst payload = message.payload;\n\n\t\tswitch (message.type) {\n\t\t\tcase ServerMessageType.Answer:\n\t\t\t\tawait this._negotiator.handleSDP(message.type, payload.sdp);\n\t\t\t\tbreak;\n\t\t\tcase ServerMessageType.Candidate:\n\t\t\t\tawait this._negotiator.handleCandidate(payload.candidate);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlogger.warn(\n\t\t\t\t\t\"Unrecognized message type:\",\n\t\t\t\t\tmessage.type,\n\t\t\t\t\t\"from peer:\",\n\t\t\t\t\tthis.peer,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n","import logger from \"./logger\";\nimport type { MediaConnection } from \"./mediaconnection\";\nimport type { DataConnection } from \"./dataconnection/DataConnection\";\nimport {\n\tBaseConnectionErrorType,\n\tConnectionType,\n\tPeerErrorType,\n\tServerMessageType,\n} from \"./enums\";\nimport type { BaseConnection, BaseConnectionEvents } from \"./baseconnection\";\nimport type { ValidEventTypes } from \"eventemitter3\";\n\n/**\n * Manages all negotiations between Peers.\n */\nexport class Negotiator<\n\tEvents extends ValidEventTypes,\n\tConnectionType extends BaseConnection<Events | BaseConnectionEvents>,\n> {\n\tconstructor(readonly connection: ConnectionType) {}\n\n\t/** Returns a PeerConnection object set up correctly (for data, media). */\n\tstartConnection(options: any) {\n\t\tconst peerConnection = this._startPeerConnection();\n\n\t\t// Set the connection's PC.\n\t\tthis.connection.peerConnection = peerConnection;\n\n\t\tif (this.connection.type === ConnectionType.Media && options._stream) {\n\t\t\tthis._addTracksToConnection(options._stream, peerConnection);\n\t\t}\n\n\t\t// What do we need to do now?\n\t\tif (options.originator) {\n\t\t\tconst dataConnection = this.connection;\n\n\t\t\tconst config: RTCDataChannelInit = { ordered: !!options.reliable };\n\n\t\t\tconst dataChannel = peerConnection.createDataChannel(\n\t\t\t\tdataConnection.label,\n\t\t\t\tconfig,\n\t\t\t);\n\t\t\tdataConnection._initializeDataChannel(dataChannel);\n\n\t\t\tvoid this._makeOffer();\n\t\t} else {\n\t\t\tvoid this.handleSDP(\"OFFER\", options.sdp);\n\t\t}\n\t}\n\n\t/** Start a PC. */\n\tprivate _startPeerConnection(): RTCPeerConnection {\n\t\tlogger.log(\"Creating RTCPeerConnection.\");\n\n\t\tconst peerConnection = new RTCPeerConnection(\n\t\t\tthis.connection.provider.options.config,\n\t\t);\n\n\t\tthis._setupListeners(peerConnection);\n\n\t\treturn peerConnection;\n\t}\n\n\t/** Set up various WebRTC listeners. */\n\tprivate _setupListeners(peerConnection: RTCPeerConnection) {\n\t\tconst peerId = this.connection.peer;\n\t\tconst connectionId = this.connection.connectionId;\n\t\tconst connectionType = this.connection.type;\n\t\tconst provider = this.connection.provider;\n\n\t\t// ICE CANDIDATES.\n\t\tlogger.log(\"Listening for ICE candidates.\");\n\n\t\tpeerConnection.onicecandidate = (evt) => {\n\t\t\tif (!evt.candidate || !evt.candidate.candidate) return;\n\n\t\t\tlogger.log(`Received ICE candidates for ${peerId}:`, evt.candidate);\n\n\t\t\tprovider.socket.send({\n\t\t\t\ttype: ServerMessageType.Candidate,\n\t\t\t\tpayload: {\n\t\t\t\t\tcandidate: evt.candidate,\n\t\t\t\t\ttype: connectionType,\n\t\t\t\t\tconnectionId: connectionId,\n\t\t\t\t},\n\t\t\t\tdst: peerId,\n\t\t\t});\n\t\t};\n\n\t\tpeerConnection.oniceconnectionstatechange = () => {\n\t\t\tswitch (peerConnection.iceConnectionState) {\n\t\t\t\tcase \"failed\":\n\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\"iceConnectionState is failed, closing connections to \" + peerId,\n\t\t\t\t\t);\n\t\t\t\t\tthis.connection.emitError(\n\t\t\t\t\t\tBaseConnectionErrorType.NegotiationFailed,\n\t\t\t\t\t\t\"Negotiation of connection to \" + peerId + \" failed.\",\n\t\t\t\t\t);\n\t\t\t\t\tthis.connection.close();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"closed\":\n\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\"iceConnectionState is closed, closing connections to \" + peerId,\n\t\t\t\t\t);\n\t\t\t\t\tthis.connection.emitError(\n\t\t\t\t\t\tBaseConnectionErrorType.ConnectionClosed,\n\t\t\t\t\t\t\"Connection to \" + peerId + \" closed.\",\n\t\t\t\t\t);\n\t\t\t\t\tthis.connection.close();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"disconnected\":\n\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\"iceConnectionState changed to disconnected on the connection with \" +\n\t\t\t\t\t\t\tpeerId,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"completed\":\n\t\t\t\t\tpeerConnection.onicecandidate = () => {};\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tthis.connection.emit(\n\t\t\t\t\"iceStateChanged\",\n\t\t\t\tpeerConnection.iceConnectionState,\n\t\t\t);\n\t\t};\n\n\t\t// DATACONNECTION.\n\t\tlogger.log(\"Listening for data channel\");\n\t\t// Fired between offer and answer, so options should already be saved\n\t\t// in the options hash.\n\t\tpeerConnection.ondatachannel = (evt) => {\n\t\t\tlogger.log(\"Received data channel\");\n\n\t\t\tconst dataChannel = evt.channel;\n\t\t\tconst connection = <DataConnection>(\n\t\t\t\tprovider.getConnection(peerId, connectionId)\n\t\t\t);\n\n\t\t\tconnection._initializeDataChannel(dataChannel);\n\t\t};\n\n\t\t// MEDIACONNECTION.\n\t\tlogger.log(\"Listening for remote stream\");\n\n\t\tpeerConnection.ontrack = (evt) => {\n\t\t\tlogger.log(\"Received remote stream\");\n\n\t\t\tconst stream = evt.streams[0];\n\t\t\tconst connection = provider.getConnection(peerId, connectionId);\n\n\t\t\tif (connection.type === ConnectionType.Media) {\n\t\t\t\tconst mediaConnection = <MediaConnection>connection;\n\n\t\t\t\tthis._addStreamToMediaConnection(stream, mediaConnection);\n\t\t\t}\n\t\t};\n\t}\n\n\tcleanup(): void {\n\t\tlogger.log(\"Cleaning up PeerConnection to \" + this.connection.peer);\n\n\t\tconst peerConnection = this.connection.peerConnection;\n\n\t\tif (!peerConnection) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.connection.peerConnection = null;\n\n\t\t//unsubscribe from all PeerConnection's events\n\t\tpeerConnection.onicecandidate =\n\t\t\tpeerConnection.oniceconnectionstatechange =\n\t\t\tpeerConnection.ondatachannel =\n\t\t\tpeerConnection.ontrack =\n\t\t\t\t() => {};\n\n\t\tconst peerConnectionNotClosed = peerConnection.signalingState !== \"closed\";\n\t\tlet dataChannelNotClosed = false;\n\n\t\tconst dataChannel = this.connection.dataChannel;\n\n\t\tif (dataChannel) {\n\t\t\tdataChannelNotClosed =\n\t\t\t\t!!dataChannel.readyState && dataChannel.readyState !== \"closed\";\n\t\t}\n\n\t\tif (peerConnectionNotClosed || dataChannelNotClosed) {\n\t\t\tpeerConnection.close();\n\t\t}\n\t}\n\n\tprivate async _makeOffer(): Promise<void> {\n\t\tconst peerConnection = this.connection.peerConnection;\n\t\tconst provider = this.connection.provider;\n\n\t\ttry {\n\t\t\tconst offer = await peerConnection.createOffer(\n\t\t\t\tthis.connection.options.constraints,\n\t\t\t);\n\n\t\t\tlogger.log(\"Created offer.\");\n\n\t\t\tif (\n\t\t\t\tthis.connection.options.sdpTransform &&\n\t\t\t\ttypeof this.connection.options.sdpTransform === \"function\"\n\t\t\t) {\n\t\t\t\toffer.sdp =\n\t\t\t\t\tthis.connection.options.sdpTransform(offer.sdp) || offer.sdp;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tawait peerConnection.setLocalDescription(offer);\n\n\t\t\t\tlogger.log(\n\t\t\t\t\t\"Set localDescription:\",\n\t\t\t\t\toffer,\n\t\t\t\t\t`for:${this.connection.peer}`,\n\t\t\t\t);\n\n\t\t\t\tlet payload: any = {\n\t\t\t\t\tsdp: offer,\n\t\t\t\t\ttype: this.connection.type,\n\t\t\t\t\tconnectionId: this.connection.connectionId,\n\t\t\t\t\tmetadata: this.connection.metadata,\n\t\t\t\t};\n\n\t\t\t\tif (this.connection.type === ConnectionType.Data) {\n\t\t\t\t\tconst dataConnection = <DataConnection>(<unknown>this.connection);\n\n\t\t\t\t\tpayload = {\n\t\t\t\t\t\t...payload,\n\t\t\t\t\t\tlabel: dataConnection.label,\n\t\t\t\t\t\treliable: dataConnection.reliable,\n\t\t\t\t\t\tserialization: dataConnection.serialization,\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tprovider.socket.send({\n\t\t\t\t\ttype: ServerMessageType.Offer,\n\t\t\t\t\tpayload,\n\t\t\t\t\tdst: this.connection.peer,\n\t\t\t\t});\n\t\t\t} catch (err) {\n\t\t\t\t// TODO: investigate why _makeOffer is being called from the answer\n\t\t\t\tif (\n\t\t\t\t\terr !=\n\t\t\t\t\t\"OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer\"\n\t\t\t\t) {\n\t\t\t\t\tprovider.emitError(PeerErrorType.WebRTC, err);\n\t\t\t\t\tlogger.log(\"Failed to setLocalDescription, \", err);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err_1) {\n\t\t\tprovider.emitError(PeerErrorType.WebRTC, err_1);\n\t\t\tlogger.log(\"Failed to createOffer, \", err_1);\n\t\t}\n\t}\n\n\tprivate async _makeAnswer(): Promise<void> {\n\t\tconst peerConnection = this.connection.peerConnection;\n\t\tconst provider = this.connection.provider;\n\n\t\ttry {\n\t\t\tconst answer = await peerConnection.createAnswer();\n\t\t\tlogger.log(\"Created answer.\");\n\n\t\t\tif (\n\t\t\t\tthis.connection.options.sdpTransform &&\n\t\t\t\ttypeof this.connection.options.sdpTransform === \"function\"\n\t\t\t) {\n\t\t\t\tanswer.sdp =\n\t\t\t\t\tthis.connection.options.sdpTransform(answer.sdp) || answer.sdp;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tawait peerConnection.setLocalDescription(answer);\n\n\t\t\t\tlogger.log(\n\t\t\t\t\t`Set localDescription:`,\n\t\t\t\t\tanswer,\n\t\t\t\t\t`for:${this.connection.peer}`,\n\t\t\t\t);\n\n\t\t\t\tprovider.socket.send({\n\t\t\t\t\ttype: ServerMessageType.Answer,\n\t\t\t\t\tpayload: {\n\t\t\t\t\t\tsdp: answer,\n\t\t\t\t\t\ttype: this.connection.type,\n\t\t\t\t\t\tconnectionId: this.connection.connectionId,\n\t\t\t\t\t},\n\t\t\t\t\tdst: this.connection.peer,\n\t\t\t\t});\n\t\t\t} catch (err) {\n\t\t\t\tprovider.emitError(PeerErrorType.WebRTC, err);\n\t\t\t\tlogger.log(\"Failed to setLocalDescription, \", err);\n\t\t\t}\n\t\t} catch (err_1) {\n\t\t\tprovider.emitError(PeerErrorType.WebRTC, err_1);\n\t\t\tlogger.log(\"Failed to create answer, \", err_1);\n\t\t}\n\t}\n\n\t/** Handle an SDP. */\n\tasync handleSDP(type: string, sdp: any): Promise<void> {\n\t\tsdp = new RTCSessionDescription(sdp);\n\t\tconst peerConnection = this.connection.peerConnection;\n\t\tconst provider = this.connection.provider;\n\n\t\tlogger.log(\"Setting remote description\", sdp);\n\n\t\tconst self = this;\n\n\t\ttry {\n\t\t\tawait peerConnection.setRemoteDescription(sdp);\n\t\t\tlogger.log(`Set remoteDescription:${type} for:${this.connection.peer}`);\n\t\t\tif (type === \"OFFER\") {\n\t\t\t\tawait self._makeAnswer();\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tprovider.emitError(PeerErrorType.WebRTC, err);\n\t\t\tlogger.log(\"Failed to setRemoteDescription, \", err);\n\t\t}\n\t}\n\n\t/** Handle a candidate. */\n\tasync handleCandidate(ice: RTCIceCandidate) {\n\t\tlogger.log(`handleCandidate:`, ice);\n\n\t\ttry {\n\t\t\tawait this.connection.peerConnection.addIceCandidate(ice);\n\t\t\tlogger.log(`Added ICE candidate for:${this.connection.peer}`);\n\t\t} catch (err) {\n\t\t\tthis.connection.provider.emitError(PeerErrorType.WebRTC, err);\n\t\t\tlogger.log(\"Failed to handleCandidate, \", err);\n\t\t}\n\t}\n\n\tprivate _addTracksToConnection(\n\t\tstream: MediaStream,\n\t\tpeerConnection: RTCPeerConnection,\n\t): void {\n\t\tlogger.log(`add tracks from stream ${stream.id} to peer connection`);\n\n\t\tif (!peerConnection.addTrack) {\n\t\t\treturn logger.error(\n\t\t\t\t`Your browser does't support RTCPeerConnection#addTrack. Ignored.`,\n\t\t\t);\n\t\t}\n\n\t\tstream.getTracks().forEach((track) => {\n\t\t\tpeerConnection.addTrack(track, stream);\n\t\t});\n\t}\n\n\tprivate _addStreamToMediaConnection(\n\t\tstream: MediaStream,\n\t\tmediaConnection: MediaConnection,\n\t): void {\n\t\tlogger.log(\n\t\t\t`add stream ${stream.id} to media connection ${mediaConnection.connectionId}`,\n\t\t);\n\n\t\tmediaConnection.addStream(stream);\n\t}\n}\n","export enum ConnectionType {\n\tData = \"data\",\n\tMedia = \"media\",\n}\n\nexport enum PeerErrorType {\n\t/**\n\t * The client's browser does not support some or all WebRTC features that you are trying to use.\n\t */\n\tBrowserIncompatible = \"browser-incompatible\",\n\t/**\n\t * You've already disconnected this peer from the server and can no longer make any new connections on it.\n\t */\n\tDisconnected = \"disconnected\",\n\t/**\n\t * The ID passed into the Peer constructor contains illegal characters.\n\t */\n\tInvalidID = \"invalid-id\",\n\t/**\n\t * The API key passed into the Peer constructor contains illegal characters or is not in the system (cloud server only).\n\t */\n\tInvalidKey = \"invalid-key\",\n\t/**\n\t * Lost or cannot establish a connection to the signalling server.\n\t */\n\tNetwork = \"network\",\n\t/**\n\t * The peer you're trying to connect to does not exist.\n\t */\n\tPeerUnavailable = \"peer-unavailable\",\n\t/**\n\t * PeerJS is being used securely, but the cloud server does not support SSL. Use a custom PeerServer.\n\t */\n\tSslUnavailable = \"ssl-unavailable\",\n\t/**\n\t * Unable to reach the server.\n\t */\n\tServerError = \"server-error\",\n\t/**\n\t * An error from the underlying socket.\n\t */\n\tSocketError = \"socket-error\",\n\t/**\n\t * The underlying socket closed unexpectedly.\n\t */\n\tSocketClosed = \"socket-closed\",\n\t/**\n\t * The ID passed into the Peer constructor is already taken.\n\t *\n\t * :::caution\n\t * This error is not fatal if your peer has open peer-to-peer connections.\n\t * This can happen if you attempt to {@apilink Peer.reconnect} a peer that has been disconnected from the server,\n\t * but its old ID has now been taken.\n\t * :::\n\t */\n\tUnavailableID = \"unavailable-id\",\n\t/**\n\t * Native WebRTC errors.\n\t */\n\tWebRTC = \"webrtc\",\n}\n\nexport enum BaseConnectionErrorType {\n\tNegotiationFailed = \"negotiation-failed\",\n\tConnectionClosed = \"connection-closed\",\n}\n\nexport enum DataConnectionErrorType {\n\tNotOpenYet = \"not-open-yet\",\n\tMessageToBig = \"message-too-big\",\n}\n\nexport enum SerializationType {\n\tBinary = \"binary\",\n\tBinaryUTF8 = \"binary-utf8\",\n\tJSON = \"json\",\n\tNone = \"raw\",\n}\n\nexport enum SocketEventType {\n\tMessage = \"message\",\n\tDisconnected = \"disconnected\",\n\tError = \"error\",\n\tClose = \"close\",\n}\n\nexport enum ServerMessageType {\n\tHeartbeat = \"HEARTBEAT\",\n\tCandidate = \"CANDIDATE\",\n\tOffer = \"OFFER\",\n\tAnswer = \"ANSWER\",\n\tOpen = \"OPEN\", // The connection to the server is open.\n\tError = \"ERROR\", // Server error.\n\tIdTaken = \"ID-TAKEN\", // The selected ID is taken.\n\tInvalidKey = \"INVALID-KEY\", // The given API key cannot be found.\n\tLeave = \"LEAVE\", // Another peer has closed its connection to this peer.\n\tExpire = \"EXPIRE\", // The offer sent to a peer has expired without response.\n}\n","import type { Peer } from \"./peer\";\nimport type { ServerMessage } from \"./servermessage\";\nimport type { ConnectionType } from \"./enums\";\nimport { BaseConnectionErrorType } from \"./enums\";\nimport {\n\tEventEmitterWithError,\n\ttype EventsWithError,\n\tPeerError,\n} from \"./peerError\";\nimport type { ValidEventTypes } from \"eventemitter3\";\n\nexport interface BaseConnectionEvents<\n\tErrorType extends string = BaseConnectionErrorType,\n> extends EventsWithError<ErrorType> {\n\t/**\n\t * Emitted when either you or the remote peer closes the connection.\n\t *\n\t * ```ts\n\t * connection.on('close', () => { ... });\n\t * ```\n\t */\n\tclose: () => void;\n\t/**\n\t * ```ts\n\t * connection.on('error', (error) => { ... });\n\t * ```\n\t */\n\terror: (error: PeerError<`${ErrorType}`>) => void;\n\ticeStateChanged: (state: RTCIceConnectionState) => void;\n}\n\nexport abstract class BaseConnection<\n\tSubClassEvents extends ValidEventTypes,\n\tErrorType extends string = never,\n> extends EventEmitterWithError<\n\tErrorType | BaseConnectionErrorType,\n\tSubClassEvents & BaseConnectionEvents<BaseConnectionErrorType | ErrorType>\n> {\n\tprotected _open = false;\n\n\t/**\n\t * Any type of metadata associated with the connection,\n\t * passed in by whoever initiated the connection.\n\t */\n\treadonly metadata: any;\n\tconnectionId: string;\n\n\tpeerConnection: RTCPeerConnection;\n\tdataChannel: RTCDataChannel;\n\n\tabstract get type(): ConnectionType;\n\n\t/**\n\t * The optional label passed in or assigned by PeerJS when the connection was initiated.\n\t */\n\tlabel: string;\n\n\t/**\n\t * Whether the media connection is active (e.g. your call has been answered).\n\t * You can check this if you want to set a maximum wait time for a one-sided call.\n\t */\n\tget open() {\n\t\treturn this._open;\n\t}\n\n\tprotected constructor(\n\t\t/**\n\t\t * The ID of the peer on the other end of this connection.\n\t\t */\n\t\treadonly peer: string,\n\t\tpublic provider: Peer,\n\t\treadonly options: any,\n\t) {\n\t\tsuper();\n\n\t\tthis.metadata = options.metadata;\n\t}\n\n\tabstract close(): void;\n\n\t/**\n\t * @internal\n\t */\n\tabstract handleMessage(message: ServerMessage): void;\n\n\t/**\n\t * Called by the Negotiator when the DataChannel is ready.\n\t * @internal\n\t * */\n\tabstract _initializeDataChannel(dc: RTCDataChannel): void;\n}\n","import { EventEmitter } from \"eventemitter3\";\nimport logger from \"./logger\";\n\nexport interface EventsWithError<ErrorType extends string> {\n\terror: (error: PeerError<`${ErrorType}`>) => void;\n}\n\nexport class EventEmitterWithError<\n\tErrorType extends string,\n\tEvents extends EventsWithError<ErrorType>,\n> extends EventEmitter<Events, never> {\n\t/**\n\t * Emits a typed error message.\n\t *\n\t * @internal\n\t */\n\temitError(type: ErrorType, err: string | Error): void {\n\t\tlogger.error(\"Error:\", err);\n\n\t\t// @ts-ignore\n\t\tthis.emit(\"error\", new PeerError<`${ErrorType}`>(`${type}`, err));\n\t}\n}\n/**\n * A PeerError is emitted whenever an error occurs.\n * It always has a `.type`, which can be used to identify the error.\n */\nexport class PeerError<T extends string> extends Error {\n\t/**\n\t * @internal\n\t */\n\tconstructor(type: T, err: Error | string) {\n\t\tif (typeof err === \"string\") {\n\t\t\tsuper(err);\n\t\t} else {\n\t\t\tsuper();\n\t\t\tObject.assign(this, err);\n\t\t}\n\n\t\tthis.type = type;\n\t}\n\n\tpublic type: T;\n}\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","export const randomToken = () => Math.random().toString(36).slice(2);\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","extendStatics","LogLevel","ConnectionType","PeerErrorType","BaseConnectionErrorType","DataConnectionErrorType","SerializationType","SocketEventType","ServerMessageType","$3f7790a221c2f3e5$var$_a","$3f7790a221c2f3e5$var$_b","$3f7790a221c2f3e5$var$_c","$55e90223fe532944$export$243e62d78d3b544d","$e07633d19f7426e9$export$3157d57b4135e3bc","$e07633d19f7426e9$export$9547aaa2e39030ff","$e07633d19f7426e9$export$7974935686149686","$e07633d19f7426e9$export$49ae800c114df41d","$e07633d19f7426e9$export$89f507cf986a947","$e07633d19f7426e9$export$3b5c4a4b6354f023","$e07633d19f7426e9$export$adb4a1754da6f10d","$5dbeafcd6e23d52f$exports","$5dbeafcd6e23d52f$export$bf87d8a088c760fb","$e6c5ba1e7517ae08$exports","$31bcb34ba1ba037f$export$78406e843f5312da","byte","concat","Math","abs","toString","padStart","$e6c5ba1e7517ae08$export$f9de6ca0bc043724","$268a69da4c3a2b66$export$bcbeb236456bc779","type","data","$8bb13aa6087251ac$exports","$8bb13aa6087251ac$export$ef3eed12d06c0285","$8bb13aa6087251ac$var$__extends","d","b","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","_super","DecodeError","message","_this","value","name","Error","$518bfda92fef5c7f$export$8532a5209571c04a","view","offset","high","floor","setUint32","$518bfda92fef5c7f$export$69825c7adcc820c6","getInt32","getUint32","$90f42a47dc95aba0$export$8654479533463da1","encode","object","msec","sec","nsec","nsecInSec","Date","$90f42a47dc95aba0$export$2fd05b828dd81159","_a","rv","Uint8Array","DataView","buffer","secHigh","secLow","date","getTime","decode","timeSpec","$90f42a47dc95aba0$export$abfc8800a5159711","byteOffset","byteLength","nsec30AndSecHigh2","length","$f1fa32c4c66b90ce$export$12677a794dbd89d7","ExtensionCodec","builtInEncoders","builtInDecoders","encoders","decoders","register","index","tryToEncode","context","i","encodeExt","decodeExt","defaultCodec","$43163e488488b0b2$exports","$3f7790a221c2f3e5$var$TEXT_ENCODING_AVAILABLE","env","TextEncoder","TextDecoder","$3f7790a221c2f3e5$export$b61de95301265227","str","strLength","pos","charCodeAt","extra","$3f7790a221c2f3e5$var$sharedTextEncoder","undefined","$3f7790a221c2f3e5$export$ed34c0622b397238","$3f7790a221c2f3e5$export$34cfdc82d430524","encodeInto","output","outputOffset","subarray","$3f7790a221c2f3e5$export$551117984c2adf4f","bytes","inputOffset","end","units","result","byte1","push","byte2","byte3","unit","fromCharCode","apply","$3f7790a221c2f3e5$var$sharedTextDecoder","$3f7790a221c2f3e5$export$d866281c5a66d1ef","$e2b22818b7517d55$export$f8d669c2a17882f2","ArrayBuffer","isView","from","$a5b0b5bb55e8ea9d$export$529b830450faf29c","CachedKeyDecoder","maxKeyLength","maxLengthPerKey","hit","miss","caches","canBeCached","find","records","FIND_CHUNK","_i","records_1","record","recordBytes","j","store","random","cachedValue","slicedCopyOfBytes","slice","$e6c5ba1e7517ae08$var$__generator","thisArg","body","f","y","t","g","_","label","sent","trys","ops","next","verb","Symbol","iterator","step","op","done","pop","$e6c5ba1e7517ae08$var$__asyncValues","o","asyncIterator","m","__values","Promise","resolve","reject","settle","then","$e6c5ba1e7517ae08$var$__await","$e6c5ba1e7517ae08$var$__asyncGenerator","_arguments","generator","q","a","resume","r","fulfill","shift","$e6c5ba1e7517ae08$var$isValidMapKeyType","key","keyType","$e6c5ba1e7517ae08$var$EMPTY_VIEW","$e6c5ba1e7517ae08$var$EMPTY_BYTES","$e6c5ba1e7517ae08$export$449c37eaf7093493","getInt8","$e6c5ba1e7517ae08$var$MORE_DATA","$e6c5ba1e7517ae08$var$sharedCachedKeyDecoder","Decoder","extensionCodec","maxStrLength","maxBinLength","maxArrayLength","maxMapLength","maxExtLength","keyDecoder","totalPos","headByte","stack","reinitializeState","setBuffer","bufferView","appendBuffer","hasRemaining","remainingData","newData","newBuffer","size","createExtraByteError","posToShow","RangeError","doDecodeSync","decodeMulti","decodeAsync","stream","stream_1","stream_1_1","e_1","P","decoded","_b","_c","error","return","fulfilled","rejected","adopt","decodeArrayStream","decodeMultiAsync","decodeStream","isArray","arguments","isArrayHeaderRequired","arrayItemsLeft","stream_2","stream_2_1","e_2","e_3","readArraySize","complete","DECODE","readHeadByte","pushMapState","pushArrayState","decodeUtf8String","readF32","readF64","readU8","readU16","readU32","readU64","readI8","readI16","readI32","readI64","lookU8","lookU16","lookU32","decodeBinary","decodeExtension","state","array","position","map","readCount","headerOffset","stringBytes","stateIsMapKey","headOffset","extType","getUint8","getUint16","getInt16","getFloat32","getFloat64","$de4ae0b6ff372b32$exports","$de4ae0b6ff372b32$export$bf99ef56e8bd104","$de4ae0b6ff372b32$var$__generator","$de4ae0b6ff372b32$var$__await","$de4ae0b6ff372b32$var$__asyncGenerator","streamLike","$de4ae0b6ff372b32$export$f62cf0e66867a58e","reader","getReader","read","$de4ae0b6ff372b32$var$assertNonNull","releaseLock","$79f3aa6fd9a8a1cb$export$ca6ec972f712a9eb","options","ensureAsyncIterable","decoder","$c94702bf03c532e7$export$a50aceb0e02a00aa","Encoder","maxDepth","initialBufferSize","sortKeys","forceFloat32","ignoreUndefined","forceIntegerToFloat","encodeSharedRef","doEncode","depth","encodeNil","encodeBoolean","encodeNumber","encodeString","encodeObject","ensureBufferSizeToWrite","sizeToWrite","requiredSize","resizeBuffer","newSize","newBytes","newView","writeU8","Number","isSafeInteger","writeU16","writeU32","writeU64","writeI8","writeI16","writeI32","writeI64","writeF32","writeF64","writeStringHeader","maxHeaderSize","ext","encodeExtension","encodeArray","encodeBinary","encodeMap","writeU8a","object_1","item","countWithoutUndefined","keys","count","keys_1","sort","keys_2","setUint8","values","setInt8","setUint16","setInt16","setInt32","setFloat32","setFloat64","$55e90223fe532944$export$2e2bcd8739ae039","logLevel","_logLevel","log","args","All","_print","warn","Warnings","Errors","setLogFunction","fn","rest","copy","console","Disabled","$ee2f7acfd22ad8cb$export$89e6bb5ad64bf4a","connection","startConnection","peerConnection","_startPeerConnection","Media","_stream","_addTracksToConnection","originator","dataConnection","config","ordered","reliable","dataChannel","createDataChannel","_initializeDataChannel","_makeOffer","handleSDP","sdp","RTCPeerConnection","provider","_setupListeners","peerId","peer","connectionId","connectionType","onicecandidate","evt","candidate","socket","send","Candidate","payload","dst","oniceconnectionstatechange","iceConnectionState","emitError","NegotiationFailed","close","ConnectionClosed","emit","ondatachannel","channel","getConnection","ontrack","streams","_addStreamToMediaConnection","cleanup","peerConnectionNotClosed","signalingState","dataChannelNotClosed","readyState","offer","createOffer","constraints","sdpTransform","setLocalDescription","metadata","Data","serialization","Offer","err","WebRTC","err_1","_makeAnswer","answer","createAnswer","Answer","RTCSessionDescription","setRemoteDescription","self","handleCandidate","ice","addIceCandidate","id","addTrack","getTracks","forEach","track","mediaConnection","addStream","$1961087dd546fd56$exports","$1961087dd546fd56$var$has","$1961087dd546fd56$var$prefix","$1961087dd546fd56$var$Events","$1961087dd546fd56$var$EE","once","$1961087dd546fd56$var$addListener","emitter","event","listener","_events","_eventsCount","$1961087dd546fd56$var$clearEvent","$1961087dd546fd56$var$EventEmitter","eventNames","events","names","getOwnPropertySymbols","listeners","handlers","l","ee","listenerCount","a1","a2","a3","a4","a5","len","removeListener","on","removeAllListeners","off","addListener","prefixed","EventEmitter","$428dbabfb6f47b54$export$6a678e589c8a4542","$428dbabfb6f47b54$export$98871882f492de82","assign","$76eedc1a03766751$export$23a2a68283c24d80","open","_open","$eb916fa843978df9$export$4e61f672936bec77","$f7363ab6888d1e18$export$d365f7ad9d7df9c9","ID_PREFIX","_1","MAX_BUFFERED_AMOUNT","_negotiator","_payload","dc","onopen","onmessage","onclose","flush","__peerData","_removeConnection","chunked","NotOpenYet","_send","handleMessage","$b68ef8ad985e69ce$export$72aa44612e2200cd","_CHUNK_SIZE","_splitStream","TransformStream","transform","chunk","controller","split","enqueue","_rawSendStream","WritableStream","write","openEvent","addEventListener","bufferedAmount","writer","writable","getWriter","_rawReadStream","ReadableStream","start","readable","pipeTo","binaryType","bufferedAmountLowThreshold","$115c516f1c55edeb$export$80f5de1a66c4d624","_encoder","msg","decodeMultiStream","MsgPack"],"version":3,"file":"serializer.msgpack.mjs.map"}